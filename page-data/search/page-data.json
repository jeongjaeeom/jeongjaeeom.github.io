{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"리눅스 서버 설치 후 기본적인 터미널 설정을 진행해봅니다.   인스턴스의  기준으로 작성되었습니다. 터미널 세션 타임아웃(Sessio Timeout) 설정 Sessio Timeout을 설정 하여 일정 시간 작업을 하지 않을 경우 터미널 연결을 해제 하도록 설정할 수 있습니다. 프로파일(.profile) 파일 생성 및 내용 입력  - history 명령 결…","fields":{"slug":"/linux-basic-terminal-settings/"},"frontmatter":{"date":"October 17, 2022","title":"리눅스 서버 터미널 기본 설정","tags":["linux","terminal","shell","aws"]},"rawMarkdownBody":"\n리눅스 서버 설치 후 기본적인 터미널 설정을 진행해봅니다.  \n> `AWS EC2`인스턴스의 `Amazon Linux 2` 기준으로 작성되었습니다.\n\n## 터미널 세션 타임아웃(Sessio Timeout) 설정\nSessio Timeout을 설정 하여 일정 시간 작업을 하지 않을 경우 터미널 연결을 해제 하도록 설정할 수 있습니다.\n\n프로파일(.profile) 파일 생성 및 내용 입력\n```shell\n$ sudo vi ~/.profile\nHISTTIMEFORMAT=\"%F %T -- \"\nexport HISTTIMEFORMAT\nexport TMOUT=600 \n\n$ source ~/.profile\n```\n* `HISTTIMEFORMAT` - history 명령 결과에 시간 값을 추가한다.\n* `TMOUT=600` - 세션 타임아웃을 설정한다(초 단위).\n\n\n## 쉘(Shell) Prompt 변경하기\nBastion 서버 등과 같이 서버를 구분해야하는 경우에 Shell Prompt를 설정하여 서버 관리자의 인적 장애를 예방할 수 있다.\n\n```shell\n$ sudo vi ~/.bashrc\nUSERNAME=BASTION\nPS1='[\\e[1;31m$USERNAME\\e[0m][\\e[1;32m\\t\\e[0m][\\e[1;33m\\u\\e[0m@\\e[1;36m\\h\\e[0m \\w] \\n\\$ \\[\\033[00m\\]'\n\n$ source ~/.bashrc\n```\n\n## Logger를 사용하여 감사로그 남기기\n서버에서 작업할 경우, 작업 이력 히스토리를 기록해 두어야 장애 발싱시 원인 분석을 할 수 있습니다.\n\n```shell\n$ sudo vi ~/.bashrc\ntty=`tty | awk -F\"/dev/\" '{print $2}'`\nIP=`w | grep \"$tty\" | awk '{print $3}'`\nexport PROMPT_COMMAND='logger -p local0.debug \"[USER]$(whoami) [IP]$IP [PID]$$ [PWD]`pwd` [COMMAND] $(history 1 | sed \"s/^[ ]*[0-9]\\+[ ]*//\" )\"'\n\n$ source  ~/.bashrc\n```\n\n```shell\n$ sudo vi /etc/rsyslog.d/50-default.conf\nlocal0.*  /var/log/command.log\n\n$ sudo service rsyslog restart\n$ tail -f /var/log/command.log\n```\n## 참고\n* [인프라 공방](https://edu.nextstep.camp/c/VI4PhjPA/)\n"},{"excerpt":"우아한테크세미나 어디 가서 코프링 매우 알은 체하기!를 보고 정리한 내용입니다.    코틀린이란? JVM, 안드로이드, 자바스크립트 및 네이티브를 대상으로 하는  : 모든 프로그램 구성요소의 타입을 컴파일 시점에 알 수 있고 프로그램 안에서 객체의 필드나 메서드를 사용할 때마다 컴파일러가 타입을 검증해 준다는 뜻 젯브레인즈에서 개발한 오픈소스(아파치 라이…","fields":{"slug":"/kotlin-spring-woowahan-tech/"},"frontmatter":{"date":"October 17, 2022","title":"우아한테크세미나 코프링 정리","tags":["kotlin","spring","java","코프링"]},"rawMarkdownBody":"\n> 우아한테크세미나 [어디 가서 코프링 매우 알은 체하기!](https://www.youtube.com/watch?v=ewBri47JWII)를 보고 정리한 내용입니다.   \n\n## 코틀린이란?\n* JVM, 안드로이드, 자바스크립트 및 네이티브를 대상으로 하는 `정적 타입 지정 언어`\n  * `정적 타입 지정 언어`: 모든 프로그램 구성요소의 타입을 컴파일 시점에 알 수 있고 프로그램 안에서 객체의 필드나 메서드를 사용할 때마다 컴파일러가 타입을 검증해 준다는 뜻\n* 젯브레인즈에서 개발한 오픈소스(아파치 라이선스 2.0)\n* OO 스타일과 FP 스타일을 모두 사용할 수 있으며 두 요소를 혼합하여 사용할 수 있다.\n* 간결하고 실용적이며 안전하고 기존 언어와의 상호 운용성을 중시한다.(+코루틴)\n\n## 코틀린의 역사\n* 2011년 7월 코틀린 프로젝트 공개\n* 2012년 6월 안드로이드에서 사용 가능\n* 2016년 2월 코틀린 1.0 출시 / 스프링 이니셜라이저 지원\n* 2017년 1월 스프링 프레임워크 공식 지원\n* 2017년 5월 안드로이드 공식 지원\n* 2018년 11월 그레이들 코틀린 DSL 1.0 출시\n* 2019년 5월 안드로이드 코틀린 퍼스트\n* 2019년 9월 스프링 레퍼런스 예제 코드 제공\n* 2021년 5월 코틀린 1.5 출시\n\n## 얼마나 사용하고 있나요?\n* 지난 12개월 동안 480만 명 이상의 사용자가 사용\n* 대다수의 코틀린 개발자는 안드로이드(64%) 및 서버 측 애플리케이션 개발 (52%)에 사용한다\n* 대한민국에서 가장 인기가 많은 자바, 자연스럽게 코틀린에 대한 관심도 1위(10%)\n\n## 멀티 플랫폼 언어\n* Kotlin은 멀티플랫폼 언어이다.\n* JVM/JS/Native 등\n\n## 아이템 1. 코틀린 표준 라이브러리를 익히고 사용하라\n* 코틀린 1.3부터 모든 플랫폼에서 사용할 수 있는 `kotlin.random.Random`이 도입되었다.\n* 더 이상 `Random`을 사용할지 `ThreadLocalRandom`을 사용할지 고민할 필요가 없다.\n* 자바와 관련된 import문을 제거할 수 있다.\n* 표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 여러분보다 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다.\n* 코틀린은 읽기 전용 컬렉션과 변경 가능한 컬렉션을 구별해 제공한다.\n* 인터페이스를 만족하는 실제 컬렉션이 반환된다. 따라서 플랫폼별 컬렉션을 사용할 수 있다.  \n![코틀린 컬렉션 프레임워크 다이어그램](images/코틀린-공식문서-컬렉션프레임워크-다이어그램.png)\n\n## 코틀린 맛보기\n```kotlin\nclass Person(val name: String, val age: Int = 1) {\n    var nickname: String? = null\n}\n```\n### 자바 변환\n```java\npublic final class Person {\n   @NotNull\n   private final String name;\n   private final int age;\n   \n   @Nullable\n   private String nickname;\n   \n   public Person(String name) {\n      this(name, 1);\n   }\n   \n   public Person(@NotNull String name, int age) {\n      this.name = name;\n      this.age = age;\n   }\n\n   @NotNull\n   public final String getName() {\n      return this.name;\n   }\n   \n   public final int getAge() {\n      return this.age;\n   }\n   \n   @Nullable\n   public final String getNickname() {\n      return this.nickname;\n   }\n\n   public final void setNickname(@Nullable String var1) {\n      this.nickname = var1;\n   }\n}\n```\n\n* 코틀린은 기본적으로 널이 될수 없는 타입이고 의도적으로 `?` 키워드를 선언해야 널이 될 수 있는 타입이 된다.\n* 자바로 변환했을 때 주요 키워드는 `final`이다.\n* 기존 라이브러리를 함께 사용할 때 대부분 `final` 때문에 문제가 발생할 수 있다.\n\n## 아이템 2. 자바로 역컴파일하는 습관을 들여라\n* 코틀린 숙련도를 향상시키는 가장 좋은 방법 중 하나는 작성한 코드가 자바로 어떻게 표현되는지 확인 하는 것이다.\n* 역컴파일을 통해 예기치 않은 코드 생성을 방지할 수 있다.\n* 기존 자바 라이브러리와 프레임워크를 사용하며 문제가 발생할 때 빠르게 확인 할 수 있다.\n* IntelliJ IDEA Tools > Kotlin > Show Kotlin Bytecode => Decompile\n\n### 코틀린 컴파일\n![코틀린 컴파일](images/코틀린-컴파일.png)\n* 코틀린이 먼저 컴파일 된 후 자바가 컴파일 되고, 그 과정에서 애너테이션 프로세싱이 실행된다.\n* `애너테이션` -> 가장 자주 쓰는 것은 `롬복` 애너테이션이다.\n\n## 아이템3. 롬복 대신 데이터 클래스를 사용하라\n* 데이터를 저장하거나 전달하는 것이 주 목적인 클래스를 만드는 경우가 많다. 이러한 클래스의 일부 표준 및 유틸리티 함수는 데이터에서 기계적으로 파생된다.\n* 자바에서는 롬복의 `@Data`를 사용하여 보일러플레이트 코드를 생성한다.\n* 애너테이션 프로세서는 코틀린 컴파일 이후에 동작하기 때문에 롬복에서 생성된 자바 코드는 코틀린 코드에서 접근할 수 없다.\n* 코틀린 코드보다 자바 코드를 먼저 컴파일하도록 빌드 순서를 조정하면 롬복 문제는 해결할 수 있다.\n* 하지만 자바 코드에서 코틀린 코드를 호출할 수 없게 된다.\n* 자바에서 코틀린으로 변환 과정에서 추천하는 방법은 Delombok을 사용하여 작은 단위에 데이터 클래스(DTO등) 부터 점진적으로 변경하는 방법을 추천한다\n\n> [코틀린 1.5.20 부터 롬복 컴파일러 프러그인이 실험적으로 추가되었다.](https://kotlinlang.org/docs/lombok.html)\n\n> [Kotlin 도입 과정에서 만난 문제와 해결방법](https://d2.naver.com/helloworld/6685007)\n\n```kotlin\nval javajigi = Person(name = \"박재성\", age = 49)\nval jason = javajigi.copy(age = 30)\n\ndata class Person(val name: String, val age: Int)\n```\n\n```kotlin\ndata class RecruitmentResponse(\n    val id: Long,\n    val title: String,\n    val term: TermResponse,\n    val recruitable: Boolean,\n    val hidden: Boolean,\n    val startDateTime: LocalDateTime,\n    val endDateTime: LocalDateTime,\n    val status: RecruitmentStatus\n) {\n    constructor(recruitment: Recruitment, term: Term) : this(\n        recruitment.id,\n        recruitment.title,\n        TermResponse(term),\n        recruitment.recruitable,\n        recruitment.hidden,\n        recruitment.startDateTime,\n        recruitment.endDateTime,\n        recruitment.status\n    )\n}\n```\n\n```kotlin\n@Embeddable\ndata class RecruitmentPeriod(\n    @Column(nullable = false)\n    val startDateTime: LocalDateTime,\n\n    @Column(nullable = false)\n    val endDateTime: LocalDateTime\n) {\n    init {\n        require(endDateTime >= startDateTime) { \"시작 일시는 종료 일시보다 이후일 수 없습니다.\" }\n    }\n\n    fun contains(value: LocalDateTime): Boolean = (startDateTime..endDateTime).contains(value)\n}\n```\n\n* 위와 같이 `equals`와 `hashcode` 중요한 객체에서는 데이터클래스를 활용할 수 있다.\n\n\n## Spring Boot\n\n## 아이템 5. 변경 가능성을 제한하라\n\n\n## Persistence\n\n* Entity와 MappedSuperclass 를 왜 allOpen 하는지?\n* 프록시를 만들 수 없어서 레이지 로딩기능이 안되기 때문에 성능에 문제가 발생한다\n\n## 아이템 6. 엔티티에 데이터 클래스 사용을 피하라\n* 롬복의 @Data와 같은 맥락이다. 양방향 연관 관계의 경우 toString(), hashcode()를 호출될 때 무한 순환 참조가 발생한다.\n\n## 아이템 7. 사용자 지정 getter를 사용하라\n\n## 아이템 8. 널이 될 수 있는 타입은 빠르게 제거하라\n\n\n\n## 공부방법\n* 코틀린 공식문서!!\n* 책 - Kotlin in Action 완독 추천\n* 아름다움은 기능을 따라간다 - 설리번(건축가)\n\n## 코틀린\n* 1.5부터는 IR컴파일러 도입하여 더 성능이 좋다\n* 인텔리제이 최신버전 그레이들 최신버전 코틀린 최신버전을 사용하면 3박자가 잘 맞아 재밌게 사용할 수 있다!\n\n## 참고\n* [[LIVE 다시보기] 어디 가서 코프링 매우 알은 체하기! : 9월 우아한테크세미나](https://www.youtube.com/watch?v=ewBri47JWII)"},{"excerpt":"원격리포지터리를 옮기고 싶은 경우   옵션을 사용하여 깃 커밋 히스토리 그대로 푸시하는 방법을 알아보자.   1. 기존 프로젝트 클론 2. 신규 프로젝트  옵션으로 푸시 3. 기존 프로젝트 삭제 Reference Duplicating a repository","fields":{"slug":"/git-mirror/"},"frontmatter":{"date":"July 29, 2022","title":"Git 저장소 복제 하기","tags":["git","github","repository"]},"rawMarkdownBody":" \n\n원격리포지터리를 옮기고 싶은 경우  `--mirror` 옵션을 사용하여 깃 커밋 히스토리 그대로 푸시하는 방법을 알아보자.  \n\n\n### 1. 기존 프로젝트 클론\n```bash\n$ git clone --bare https://github.com/exampleuser/old-repository.git\n```\n\n### 2. 신규 프로젝트 `--mirror` 옵션으로 푸시\n```bash\n$ cd old-repository.git\n$ git push --mirror https://github.com/exampleuser/new-repository.git\n```\n\n### 3. 기존 프로젝트 삭제\n```bash\n$ cd ..\n$ rm -rf old-repository.git\n```\n\n## Reference\n---\n* [Duplicating a repository](https://docs.github.com/en/repositories/creating-and-managing-repositories/duplicating-a-repository)\n"},{"excerpt":"EC2 구성 AMI - Amazon Linux 2 AMI (HVM) - Kernel 5.10, SSD Volume Type 선택 도커 및 Git 설치 도커 컴포즈 설치 Pinpoint 설치 위 명령어 실행시 아래 와 같이 오류 발생하여 권한처리 후 정상동작 확인 Pinpoint Web 접속 http://[Pinpoint-Web-host]:8079 Samp…","fields":{"slug":"/pinpoint-install-with-docker/"},"frontmatter":{"date":"June 15, 2022","title":"AWS EC2 Pinpoint 설치 with docker","tags":["pinpoint","aws","java","apm","docker","docker-compose"]},"rawMarkdownBody":" \n\n## EC2 구성\n* AMI - **Amazon Linux 2 AMI (HVM) - Kernel 5.10, SSD Volume Type 선택**\n\n## 도커 및 Git 설치\n\n```bash\n# docker 설치\nsudo amazon-linux-extras install docker\n\n# docker 실행\nsudo service docker start\n\n# docker 사용자 ec2-user 그룹에 추가\nsudo usermod -a -G docker ec2-user\n\n# Git 설치\nsudo yum install git -y\n\n# 재부팅\nsudo reboot\n```\n\n## 도커 컴포즈 설치\n\n```bash\n# docker-compose 설치\nsudo curl -L https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose\n\n# 권한 수정\nsudo chmod +x /usr/local/bin/docker-compose\n\n# Verify\ndocker-compose version\n```\n\n## Pinpoint 설치\n\n```bash\ngit clone https://github.com/naver/pinpoint-docker.git\ncd pinpoint-docker\ndocker-compose pull && docker-compose up -d\n```\n\n## 위 명령어 실행시 아래 와 같이 오류 발생하여 권한처리 후 정상동작 확인\n\n```bash\n# docker-compose pull && docker-compose up -d 실행 시 오류 발생!!\nGot permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get \"http://%2Fvar%2Frun%2Fdocker.sock/v1.24/info\": dial unix /var/run/docker.sock: connect: permission denied\n\n# docker.sock 권한 변경\nsudo chmod 666 /var/run/docker.sock\n\n# 다시 실행\ndocker-compose pull && docker-compose up -d\n```\n\n## Pinpoint Web 접속\n\n- http://[Pinpoint-Web-host]:8079\n- Sample App(quickapp) 앱 확인\n\n![pinpoint-demo](images/demo.png)\n\n## Reference\n* [https://gist.github.com/npearce/6f3c7826c7499587f00957fee62f8ee9](https://gist.github.com/npearce/6f3c7826c7499587f00957fee62f8ee9)\n* [https://pinpoint-apm.gitbook.io/pinpoint/](https://pinpoint-apm.gitbook.io/pinpoint/)\n* [https://newbedev.com/shell-error-got-permission-denied-while-trying-to-connect-to-the-docker-daemon-socket-at-unix-var-run-docker-sock-get-http-2fvar-2frun-2fdocker-sock-v1-24-info-dial-unix-var-run-docker-sock-connect-permission-denied-code-example](https://newbedev.com/shell-error-got-permission-denied-while-trying-to-connect-to-the-docker-daemon-socket-at-unix-var-run-docker-sock-get-http-2fvar-2frun-2fdocker-sock-v1-24-info-dial-unix-var-run-docker-sock-connect-permission-denied-code-example)"},{"excerpt":"EC2 구성 Hbase, Collector, Web 하나의 EC2에 설치 AMI - Amazon Linux 2 AMI (HVM) - Kernel 5.10, SSD Volume Type 선택 Security Group InBound Open Port: 8000 - 9999 Pinpoint 설치 java 8 설치(Hbase 버전 지원으로 인해 java 8설치…","fields":{"slug":"/pinpoint-install/"},"frontmatter":{"date":"June 15, 2022","title":"AWS EC2 Pinpoint 설치","tags":["pinpoint","aws","java","apm"]},"rawMarkdownBody":"\n## EC2 구성\n* Hbase, Collector, Web 하나의 EC2에 설치\n* AMI - **Amazon Linux 2 AMI (HVM) - Kernel 5.10, SSD Volume Type 선택**\n* Security Group InBound Open Port: 8000 - 9999\n\n## Pinpoint 설치\njava 8 설치(Hbase 버전 지원으로 인해 java 8설치\n\n![Screen Shot 2022-01-10 at 3.16.01 PM.png](images/java-support-by-release-line.png)\n\n```bash\n# Java 8 설치\nsudo yum install -y java-1.8.0-openjdk-devel.x86_64\n\nreadlink -f /usr/bin/java\n# /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.312.b07-1.amzn2.0.2.x86_64/jre/bin/java\n# java 경로까지만 처리\n\nsudo vim /etc/profile\n# export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.312.b07-1.amzn2.0.2.x86_64\n# 해당 파일 제일 하단에 입력 후 재접속\n\n# 확인\necho $JAVA_HOME\n# /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.312.b07-1.amzn2.0.2.x86_64\n\n```\n\nHbase 설치\n\n```bash\n# HBase 다운로드\nwget https://archive.apache.org/dist/hbase/1.4.14/hbase-1.4.14-bin.tar.gz\n\n# 압축해제\ntar xvf hbase-1.4.14-bin.tar.gz\n\n# create symbolic link\nln -s hbase-1.4.14 hbase\n\n# Start hbase\nhbase/bin/start-hbase.sh\n\n# Pinpoint 에서 제공하는 Hbase 스크립트 다운로드\nwget https://raw.githubusercontent.com/pinpoint-apm/pinpoint/master/hbase/scripts/hbase-create.hbase\n\n# 스크립트 실행\nhbase/bin/hbase shell hbase-create.hbase\n```\n\n## Pinpoint Collector 설치\n\n```bash\n# Download Collector \nwget https://github.com/pinpoint-apm/pinpoint/releases/download/v2.3.3/pinpoint-collector-boot-2.3.3.jar\n\n# 실행권한 부여\nchmod +x pinpoint-collector-boot-2.3.3.jar\n\n# 실행\nnohup java -jar -Dpinpoint.zookeeper.address=localhost pinpoint-collector-boot-2.3.3.jar >/dev/null 2>&1 &\n```\n\n## Pinpoint Web 설치\n\n```bash\n# Download Web\nwget https://github.com/pinpoint-apm/pinpoint/releases/download/v2.3.3/pinpoint-web-boot-2.3.3.jar\n\n# 실행권한 부여\nchmod +x pinpoint-web-boot-2.3.3.jar\n\n# 실행\nnohup java -jar -Dpinpoint.zookeeper.address=localhost pinpoint-web-boot-2.3.3.jar >/dev/null 2>&1 &\n```\n\n## Reference\n* [https://jojoldu.tistory.com/573](https://jojoldu.tistory.com/573)\n* [https://hbase.apache.org/book.html](https://hbase.apache.org/book.html)\n* [https://pinpoint-apm.gitbook.io/pinpoint/](https://pinpoint-apm.gitbook.io/pinpoint/)"},{"excerpt":"작게 만들어라! 함수를 만드는 첫째 규칙은'작게!'다. 함수를 만드는 둘째 규칙은 '더 작게!'다 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다. 당연한 말이지만, 그래야 함수는 읽고 이해하기 쉬워진다. 한 가지만 해라! 함수는 한 가지를 해야한다. 그 한가지를 잘 해야한다. 그 한 가지만을 해야 한다. 의미 있는 이름으로 다른 함수를 추출할…","fields":{"slug":"/clean-code/"},"frontmatter":{"date":"June 13, 2022","title":"[Clean Code] 3장 함수","tags":["clean-code","Clean Code","function","container"]},"rawMarkdownBody":"\n## 작게 만들어라!\n\n* 함수를 만드는 첫째 규칙은'작게!'다. 함수를 만드는 둘째 규칙은 '더 작게!'다\n* 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다. 당연한 말이지만, 그래야 함수는 읽고 이해하기 쉬워진다.\n\n## 한 가지만 해라!\n\n* 함수는 한 가지를 해야한다. 그 한가지를 잘 해야한다. 그 한 가지만을 해야 한다.\n* 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다.\n\n## 함수당 추상화 수준은 하나로!\n\n* 함수가 확실히 '한 가지' 작업만 하려면 함수 내 모든 문자의 추상화 수준이 동일해야 한다.\n* 위 에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다. 나는 이것을 `내려가기 규칙`이라 부른다.\n\n## 서술적인 이름을 사용하라!\n\n* 좋은 이름이 주는 가치는 아무리 강조해도 지나치치 않다.\n* 한 가지만 하는 작은 함수에 좋은 이름을 붙인다면 이런 원칙을 달성함에 있어 이미 절반은 성공했다.\n\n## 함수 인수\n\n* 함수에서 이상적인 인수 개수는 0개(무항)다. 다음은 1개(단항)고, 다음은 2개(이항)다 3개(삼항)는 가능한 피하는 편이 좋다. 4개 이상(다항)은 특별한 이유가 필요하다.\n  특별한 이유가 있어도 사용하면 안된다.\n* 변환 함수에서 출력 인수를 사용하면 혼란을 일으킨다.\n* 플래그 인수는 추하다. 함수가 한꺼번에 여러가지를 처리한다고 대놓고 공표하는 셈이니까!\n* 인수가 2-3개 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 짚어본다.\n* 단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야 한다.\n\n## 부수 효과를 일으키지 마라!\n\n* 부수 효과는 거짓말이다. 함수에서 한 가지를 하겠다고 약속하고선 남모래 다른 짓도 하니까.\n* 일반적으로 출력 인수는 피해야 한다. 함수에서 상태를 변경해야 한다면 함수가 속한 객체 상태를 변경하는 방식을 택한다.\n\n## 명령과 조회를 분리하라!\n\n```java\n// \"set\"이라는 단어가 동사인지 형용사인지 분간하기 어렵다.\n// 함수를 구현한 개발자는 \"set\"을 동사로 의도했다. 하지만 if 문에 넣고 보면 형용사로 느껴진다.  \n// 그래서 if 문은 \"username 속성이 unclebob으로 설정되 어 있다면...”으로 읽힌다.  \n// \"username을 unclebob으로 설정하는데 성공하면\"으로 읽히지 않는다.\nif(set(\"username\",\"unclebob\"))...\n```\n\n```java\nif(attributeExists(\"username\")){\n    setAttribute(\"username\",\"unclebob\"); // 명령과 조회를 분리하라!\n    }\n```\n\n## 오류 코드보다 예외를 사용하라!\n\n* 명령 함수에서 오류 코드를 반환하는 방식은 명령/조회 분리 규칙을 미묘하게 위반한다.\n* 오류 코드 대신 예외를 사용하면 오류 처리 코드가 원래 코드에서 분리되므로 코드가 깔끔해진다.\n\n## try/catch 블록은 원래추하다.\n\n* 코드 구조에 혼란을 일으키며, 정상 동작과 오류 처리 동작을 뒤섞는다. 그러므로 try/catch 블록을 별도 함수로 뽑아내는 편이 좋다.\n\n## 오류 처리도 한 가지 작업이다.\n\n* 함수는 '한 가지' 작업만 해야 한다. 오류 처리도 '한 가지' 작업에 속한다. 그러므로 오류를 처리하는 함수는 오류만 처리해야 마땅하다.\n\n## 반복하지 마라!\n\n* 중복은 소프트웨어에서 모든 악의 근원이다.\n\n## 함수를 어떻게 짜죠?\n\n* 소프트웨어를 짜는 행위는 여느 글짓기와 비슷하다.\n* 처음부터 탁 짜내지 않는다. 그게 가능한 사람은 없으리라.\n\n## 결론\n\n* 프로그래밍의 기술은 언제나 언어 설계의 기술이다.\n* 대가 프로그래머는 시스템을 (구현할) 프로그램이 아니라 (풀어갈) 이야기로 여긴다. 프로그래밍 언어라는 수단을 사용해 좀 더 풍부하고 좀 더 표현력이 강한 언어를 만들어\n  이야기를 풀어간다.\n* 함수 계층이 바로 그 언어에 속한다.\n\n\n## Reference\n* [Clean Code](http://www.yes24.com/Product/Goods/11681152)"},{"excerpt":"29. Attached & Detached 컨테이너 이해하기 32. 이미지 & 컨테이너 삭제하기 이미지가 더 이상 컨테이너에서 사용되지 않고 중지된 컨테이너에 포함된 경우에만\n이미지를 제거할 수 있습니다. 중지된 컨테이너가 있는 경우 그 컨테이너에서 사용 중인 이미지를 제거할 수 없고, 먼저 그 컨테이너를 제거해야 합니다. 즉, 컨테이너가 시작되거나 중지…","fields":{"slug":"/docker/"},"frontmatter":{"date":"June 13, 2022","title":"Docker 시작하기","tags":["docker","kubernetes","k8s","container"]},"rawMarkdownBody":"\n## 29. Attached & Detached 컨테이너 이해하기\n\n```shell\n# detached mode default\n$ docker start [컨테이너ID]\n\n# attached mode default\n$ docker run [이미지ID]\n\n# 기본 연결 모드로 실행 로그 확인 가능\n$ docker run -p 3000:80 7f21a3339122\n\n# 기본 비 연결 모드로 실행 로그 확인 안됨\n$ docker start [컨테이너ID]\n\n# 컨테이너에 기록된 로그 확인\n$ docker logs musing_franklin\n\n# 컨테이너에 기록된 로그 실시간 확인\n$ docker logs -f musing_franklin\n\n```\n\n\n## 32. 이미지 & 컨테이너 삭제하기\n\n---\n\n```bash\n$ docker rm [컨테이너 ID]\n\n$ docker images\n\n# 이미지 제거\n$ docker rmi [이미지 ID]\n\n# 여러개 이미지 제거\n$ docker rmi [이미지 ID] [이미지 ID] [이미지 ID]\n```\n\n이미지가 더 이상 컨테이너에서 사용되지 않고 중지된 컨테이너에 포함된 경우에만\n이미지를 제거할 수 있습니다.\n\n중지된 컨테이너가 있는 경우 그 컨테이너에서 사용 중인 이미지를 제거할 수 없고, 먼저 그 컨테이너를 제거해야 합니다.\n\n즉, 컨테이너가 시작되거나 중지되더라도 그 컨테이너에 속한 이미지는 제거할 수 없습니다.\n우선적으로 컨테이너를 제거해야 합니다.\n\n## 33. 중지된 컨테이너 자동 제거하기\n\n---\n\n```bash\n$ docker run -p 3000:80 -d -rm 2ddf2ede7d6c\n```\n\n## 34. 작동 배경 살펴보기: 이미지 검사\n\n---\n\n```bash\n$ docker image inspect [이미지 ID]\n```\n\n## 35. 컨테이너에/컨테이너로 부터 파일 복사하기\n\n## Reference\n* [Docker & Kubernetes: The Practical Guide [2022 Edition]](https://www.udemycom/course/docker-kubernetes-the-practical-guide/)"},{"excerpt":"IT업계는 어떤 다른 업계 보다 빠르게 변화하고있다 대량생산의 시대는 끝나가고 있다. 많은 직업이 인공지능으로 대체될 가능성이 높아지고 있다. 앞으로도 지금과 같이 고분고분 말 잘들으며 일하는 수동적인 삶이 성공적인 삶일까? 어떤 삶을 사는 것이 우리를 정말 필요한 사람, 없어서는 안 되는 사람으로 만들 것인가. 그럼 어떤 삶을 살아야 하나? 책 - 린치…","fields":{"slug":"/05-responsibility-driven-design-dev-culture/"},"frontmatter":{"date":"June 01, 2022","title":"5차 강의 - 책임주도 설계, 개발문화 만들기","tags":["tdd","java","clean-code","class","oop","refactoring","immutable"]},"rawMarkdownBody":"\n* IT업계는 어떤 다른 업계 보다 빠르게 변화하고있다\n* 대량생산의 시대는 끝나가고 있다.\n* 많은 직업이 인공지능으로 대체될 가능성이 높아지고 있다.\n* 앞으로도 지금과 같이 고분고분 말 잘들으며 일하는 수동적인 삶이 성공적인 삶일까?\n* 어떤 삶을 사는 것이 우리를 정말 필요한 사람, 없어서는 안 되는 사람으로 만들 것인가.\n* 그럼 어떤 삶을 살아야 하나?\n* 책 - 린치핀 추천\n* 린치핀이란?\n  * 새로운 길을 열고, 사람들을 이끌고, 사람들을 이어주고, 일을 만들어내고,\n  * 혼란 속에서 질서를 창조하는 어떤 규칙도 없는 상황에서 무엇을 해야 하는지 찾아내는 모방 불가능한 사람들\n  * 자신의 일을 사랑하고, 하루 하루를 작품과 같은 날로 마드는 예술가 기질을 발견한 사람들\n\n* 답이 없는 곳에서 답을 찾아가는 모든 것이 예술이다\n* 예술이란?\n  * 자신의 인간성을 활용해 다른 사람의 변화를 이끌어내고자 하는 의도적인 행동\n* 조직에서 자신을 중요한 인물로 만들어주고, 경쟁에서도 우위에 서도록 만들어주는 것은 바로 감정노동이다.\n* 선택은 두 가지다.\n  * 시스템(대표적으로 회사)의 평범한 톱니바퀴로 끝날 것인가?\n  * 두려움에 굴복하고 시스템에 항복하는 선택을 할 것인가?\n  * 작지만 강한 린치핀으로 거듭날 것인가?\n  * 자신의 길을 헤쳐나가며서 그 길에서 가치를 만들어낼 것인가?\n* 눈에 띄어라.\n* 관대하라.\n* 예술을 창조하라.\n* 스스로 판단하라.\n* 사람들과 관계를 맺어라.\n* 아이디어를 공유하라.\n* 그러면 보상 받을 것이다.\n* 어떤 프로그래머의 삶을 살아야 할까?\n* 소프트웨어 장인 책 추천\n  * 소프트웨어 장인정신은 스스로가 선택한 직업에 책임감을 가지고, 지속적으로 새로운 도구와 기술을 익히며 발전하겠다는 마음가짐이다.\n  * 소프트웨어 장인정신은 책임감, 프로페셔널리즘, 실용주의, 소프트웨어 개발자로서의 자부심을 의미한다.\n* 린치팬과 소프트웨어 장인은 읽고 본인의 로드맵을 그려서 묵묵히 꾸준히 했으면 좋겠다\n* 소프트웨어 장인이 가져야할 태도의 변화\n  * 무엇인가 마음에 들지 않는다면 바꾸어라.\n  * 그것을 바꿀 수 없다면, 그에 대한 당신의 생각을 바꾸어라 - 마리 엥겔브레이트\n* 프로그래밍 역량에 대한 생각의 변화\n  * 프로그래밍 역량은 개발자가 갖추어야 할 전부라고 생각하기 보다,\n  * 개발자가 해야 하는 많은 일들 중 하나일 뿐이라고 생각하는 자세\n  * 프로그래밍 역량 외에도 테스트, 배포 자동화, 고객/구성원들과의 협업, 문화 만들기 등에도 관심을 가지는 자세\n* 테스트 코드에 대한 생각의 변화\n  * 테스트 코드 구현은 QA가 담당한다고 생각하거나, 프로덕션 코드 구현과 별도의 작업으로 생각하기보다, 테스트 코드 구현까지 완료해야 기능 구현을 완료하는 것으로 생각.\n* 레거시 코드에 대한 생각의 변화\n  * 레거시 코드를 바라볼 때 짜증나고, 고통스런 일로 바라보기 보다, 재미있고, 도전적인 문제로 바라보는 자세\n* 무리한 일정과 업무 요청에 대한 생각의 변화\n  * 무리한 일정과 변경 요구에 무조건적으로 ‘예'라고 말하기 보다, ‘아니오'라는 말을 하고 대안을 제시하는 자세\n* 자기 성장에 대한 생각의 변화\n  * 회사나 선배 개발자가 성장시켜 주기를 바라기 보다, 자신의 시간과 돈을 들여 스스로 성장하려는 자세\n  * 기업이 개발자에게 자기계발을 할 시간을 준다면 보너스나 배려로 생각한다.\n* 성장에 대한 생각의 변화\n  * 나 혼자 성장하는 것에만 관심을 가지기 보다\n  * 후배들을 키우고, 커뮤니티를 통해 같이 학습하고, 지식을 공유해 소프트웨어 산업 생태계에도 기여하려는 자세\n* 소프트웨어 장인에게 가장 필요한 자질은 정직과 용기\n  * 모르는 것에서 모른다 할 수 있는 자세 - 정직\n  * 일정에 대해 아니라고 하는 자세 - 용기\n* 왜 소프트웨어 장인의 길을 걸어야 하나?\n  * 우리가 더 행복하고, 자유롭고, 즐겁게 일하기 위해\n  * 우리가 특정 회사, 고용주에게 종속되지 않고, 인간으로서의 존엄성을 유지하면서 살아가기 위해\n  * 교육자의 삶을 병행하는 것도 좋을 것 같다\n  * 한 명이 두 세가지의 일을 하면서 자유롭게 일을 하는 시대가 오고 있다고 생각 한다 특히나 우리 업계가 가장 빠르게 변화하고 있다\n  * 너무 한 가지만 하려고 하지말자 여러가지 일을 하면서 사는 방법도 있다.\n\n#### 원시 값, 문자열 포장하면서 객체 생성시 고민하게 되는 이슈\n이슈 - 객체 생성할 때 구현 코드의 양이 증가함\n![](images/로또넘버객체포장.png)\n![](images/LottoTest.png)\n* 생성자를 여러개 만들어서 해결하면 된다.\n* 해결책 - 생성자 하나를 주 생성자로 만들어라\n* 클래스를 잘 설계한다면, 클래스는 많은 수의 생정자와 적은 수의 메서드를 포함할 것이다.\n* 2, 3개의 메서드와 5~10개의 생성자를 포함하는 것이 적당하다.\n* 이런 기준을 두는 핵심은 응집도가 높고, 견고한 클래스에는 적은 수의 메서드와 상대적으로 더 많은 수의 생성자가 존재한다는 점이다.\n* 메서드가 많아지면 클래스의 초점이 흐려지고, 단일책임원칙을 위배할 가능성이 높아진다.\n![](images/Cash생성자.png)\n\n* 생성자를 여러개 추 가할때 궁금한 것이 하나있는데 부 생성자가 주생성자를 호출안하고 다른 부생성자를 호출하는것은 어떻게 생각하세요??\n  * 괜찮다고 생각한다 그 정도의 성능저하는 감수할만 하다\n* 불변객체로 만들어라\n  * 모든 클래스를 상태변경이 불가능한 불변 클래스(immutable class)로 구현하면 유지보수성을 크게 향상시킬 수 있다.\n  * 불변 객체를 기반으로 사고하면 더 깔금하고, 더 작고, 더 쉽게 이해할 수 있는 코드를 구현할 수 있다.\n* 이슈 - immutable object 관련해 종종 듣는 질문\n  * immutable object(불변 객체)가 좋은 것은 알겠는데, 인스턴스가 너무 많이 생성되어 성능이 떨어지는 것은 아닌가?\n  * 질문삭제 리팩토링 미션에서처럼 상태가 변경되어야 하는 객체도 불변객체로 구현하는게 의미가 있을까요?\n  * 의미가 있다\n    * 불변객체로 가능한 만들려고 노력해보아라\n    * 데이터가 변경되기때문에 가변객체로 만들어야지하고 빠르게 판단하지말고 가능한 불변객체로 만들어보는 노력을 하고나서 도저히 안되면 가변객체로 하는 방향으로 해보자\n    * OOP, 클린코드를 하기위한 원칙을 가지고 프로그래밍을 하자\n\n\n"},{"excerpt":"객체 설계와 클래스 분리에 대한 두려움과 거부감 줄이기 정성적인 객체 설계의 어려움을 정량적인 원칙을 지키는 방식으로 도전 클래스 분리를 위한 정략적인 원칙 찾기 소트웍스 앤솔리지 책 중에서 객체지향 생활 체조 원칙 엘레강트 오브젝트 23가지 조언 중에서 클린코드 중에서 책을 읽으면서 정량적인 원칙을 찾기 위한 노력을 해본다 소트웍스 앤솔리지 책 중에서 …","fields":{"slug":"/03-class-seperator-immutable/"},"frontmatter":{"date":"May 04, 2022","title":"3차 강의 - 클래스 분리 & immutable","tags":["tdd","java","clean-code","class","oop","refactoring","immutable"]},"rawMarkdownBody":"\n* 객체 설계와 클래스 분리에 대한 두려움과 거부감 줄이기\n* 정성적인 객체 설계의 어려움을 정량적인 원칙을 지키는 방식으로 도전\n* 클래스 분리를 위한 정략적인 원칙 찾기\n* 소트웍스 앤솔리지 책 중에서 객체지향 생활 체조 원칙\n* 엘레강트 오브젝트 23가지 조언 중에서\n* 클린코드 중에서\n* 책을 읽으면서 정량적인 원칙을 찾기 위한 노력을 해본다\n\n#### 소트웍스 앤솔리지 책 중에서 * 객체지향 생활 체조 원칙\n\n* 원시값을 포장해라\n* getter 메서드를 최대한 사용하지 마라\n* 묻지말고 시켜라(메시지를 보내라)\n* 생성자 정말 중요하다!!\n* 일급콜렉션을 쓴다\n* 3개 이상의 인스턴스 변수를 가진 클래스를 구현하지 않는다\n    * 정말 구현하기 어렵다\n    * 인스턴스 변수를 2개만 허용한다는 의미\n* 도메인 객체와 테이블간의 관계가 1:1로 개발되고 있다 뭔가 잘못 되고 있따\n* 보통 테이블 한개당 도메인 객체는 N개가 되어야 한다\n\n#### 인스턴스 변수의 수를 줄이는 좋은 방법은?\n\n* 중복된 값 또는 불필요한 인스턴스 변수를 있는지를 확인해 제거\n* 관련있는 인스턴스 변수를 새로운 클래스(객체) 묶어서 분리\n    * 원시값 포장\n    * 일급컬렉션\n    * 관련된 인자를 새로운 클래스로 묶어라\n    * 프라이빗 메서드로 테스트 해야할 것 같으면 새로운 클래스로 분리할 것인지 의심해라 (feat. Enum)\n    * 이러면 클래스가 작아지네 TDD하기 수월해지네? 이느낌을 받아야한다\n    * Enum 안에 각각이 싱글 인스턴스이다\n    * Enum은 상태를 변경하는 로직이 절대 있으면 안된다\n\n\n#### Immutable vs Mutable\n\n* 가능한 Immutable 객체로 개발해라!\n* 문제점이 있다\n    * 방어적 복사본을 위한 새로은 인스턴스를 많이 생성하게 된다.\n    * 그럴땐 캐싱을 이용하자 ex) Map<Integer, LottoNo>\n    * 인스턴스가 많이 만들어져서 이슈가되는 경우는 극소수다.\n    * 대 부분 성능이슈는 데이터베이스 외부 API 등이다\n    * 인건비가 더 비싸다!\n* 클래스 분리할때 Immutable로 해라!!!!\n\n#### 객체지향으로 개발하게 되면\n* 첫 번째 테스트하기 쉬워진다\n* 두 번째 비지니스 로직의 중복을 제거한다\n* getter를 하는 순간 로직 중복이 일어난다\n```java\nint p = position.getPosition();\np = p + 1;\nposition.setPosition(p);\n```\n전형적인 절차지향적이다\nC의 구조체 방식(메서드가 없기때문에)\n\nEnum 은 클래스랑 똑같고\nJVM 상 하나만 가지는 것만 보장해주는 것이다\n\n#### 포비 말대로 미션 이외에도 다른 곳에서도 원시 값 포장을 적용해보려고 하고있습니다! 그런데 페이징 처리 같은 Page 도 포장을 해야할까요?\n* Page 객체는 도메인 레벨이 아닌 것 같다 그래서 해당 객체는 원시값 포장안하고 도메인 관련 객체만 하는게 좋을 것 같다\n\n#### 만약 getter를 쓰지 않는다면 이후에 Position이 ResultView까지 전달됐을 때는 어떻게 값을 얻는게 좋을까요?\n\n* 마지막 단계에선는 getter 메서드가 필요할 수 있다\n* View에서 필요한 데이터만 내려가야 한닫고 생각한다\n* 필요할 수 있지만 최소화 하자(무조건 만들지 말자!)\n\n#### UI를 제와한 모든 경우를 테스트하라는 요구사항이 있었는데요. Controller, View를 제외하고 도메인과 Service 계층이 남는데, Service가 도메인에 책임을 위임만 한다면 테스트할 필요가 없나요?\n\n* 마지막날 집중적으로 이야기 할 것이다\n* 무조건 테스트를 다 만드는게 유지보수와 개발측면에서 아닐 수 있다\n* 우선순위가 있다 서비스 레이어는 1순위는 아니다\n\n#### 래핑한 객체를 view에서 사용하기 위해 외부로 반환할 때 래핑된 그대로 반환하는 것이 좋을까요? 아니면 원시 형태로 풀어서 반환하는 것이 좋나요?\n\n* Mutable 객체를 내려주는 것 보다는 Immutable 객체를 내려 줘라\n* Mutable 객체를 어떻게 Immutable 객체로 반환해서 내려줄 것이냐가 중요하다\n* 객체를 immutable 로 개발했을때 버그가 발생할 가능성이 낮아진다\n* 상태값을 변경하는 로직이 중요한 로직이다\n* 변경점을 최소화 하자\n* 외부에서 상태값을 변경할 수 있는 여지를 줄이자\n\n#### 여기서 RacingGame.java 를 컨트롤러 라고 부를 수 있는건가요?\n\n* RacingGame은 도메인 객체이고\n* RacingMain 이 컨트롤러라고 할 수 있다\n* 굳이 컨트롤러를 만들어서 위임할 필요성 크게 의미 없다\n* 너무 레이어드 아키텍쳐에 익숙해져서 그럴 수 있다\n* 너무 강박처럼 컨트롤러 클래스 서비스 클래스 만드려고한다\n* 그런데 정말 그 레이어가 필요한지 생각해보자\n* 콘솔프로그램도 MVC기반으로 할 수 있다\n* 서비스 레이어는 왜 필요한건가요?\n\n#### 0개를 사용한다는 것과 <-> 인스턴스 변수를 2개 이하로 사용해보자는 것이 상충하는 부분도 있을것 같은데, 이 부분은 어떻게 하면 되나요?\n\n* 인스턴스 변수는 관련있는 것끼리 묶는다\n* WinningLottNumber 처림\n\n#### 로또 결과 출력때 stream 여러번 호출을 줄이기 위해서 미리 결과 map을 만들고 꺼내고있는데요\n\n* 로직에 대한 결과를 저장해놓으려고 하지말고\n* 디비를 호출하는 로직이 없다면 성능상의 큰 이슈는 없다고 생각한다\n\n#### 다른 분들이랑 커뮤니케이션 하는 능력을 키우면 좋다고 해주셨는데 의식적으로 어떤 노력을 하면 좋을까요?\n\n* 소통의 1단계는 짝 프로그래밍을 하면 좋다고 생각한다\n* 같은 관심사의 채널 내에서 짝 프로그래밍할 사람을  찾아라\n* 그 다음에는 스터디!!\n* 커뮤니터 스터디 활동 정말 추천한다!\n* 짝 프로그래밍 하고싶은데 여기 분들 뵙기 너무 힘듭니다 SLiPP 게더 놀러오십셔!\n\n#### 도메인을 잘 나눴을 때 모듈이나 프로젝트를 나눠서 이벤트호출 방식 등으로 구현을 한다면 분산트랜젝션은 전략은 어떤 방법이 있을까요?\n\n* 즉시에 100% 트랜잭션을 보장하는건 어렵다고 생각한다\n* 후처리를 통해서 데이터 정합성을 맞출 수 있는 방식으로 가야하지 않을까?\n* 예전부터 트랜잭션이 하나로 묶이고 즉시에 데이터 정합성이 보장되어야한다고 생각하는데 예전 은행 로직처럼\n* 후처리로도 데이터 정합성을 맞출 수 있는데 이런 부분을 활용하는 방법\n* 너무 DBA나 기존 생각에 갇혀있으면 즉시에 보장되어야한다고 한다 하지만 이생각을 조금 바꿔서 후처리 전략으로(큐 같은걸 사용하거나) 가는 것도 방법이라고 생각한다\n* 일시적으로 데이터 정합성이 안맞을 수 있지만 허용한 가능한 범위라고 본다면 괜찮지 않을까요\n\n#### 분산트랙젠션 답변 주신 것에 이어서.. 그러면 트랜젝션이 중요한 부분이라도 도메인끼리 조금 섞어서 단일트랜잭션을 유지하는게 나을수도 있을까요?\n\n* 여러 도메인이 후 처리가 안된다는건 너무 결합도와 커플링이 높아서 그런 것 아닐까 생각한다\n* 지속 가능한 소프트 웨어 개발이 중요하다고 생각한다\n* 객체지향 방법론을 저는 공부 많이했고 실제 사용해봐서 그런 저의 역량을 통해 더 유지보수하고 지속가능한 좋은 소프트 웨어 개발을 할 수 있을 거라 생각 합니다 이회사에도 도움이 될꺼다\n* 몸값을 올리거나 스톡을주는 회사를 가는게 빠르다"}]}},"pageContext":{}},"staticQueryHashes":[]}