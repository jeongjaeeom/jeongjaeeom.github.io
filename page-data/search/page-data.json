{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"DNS(Domain Name System)란 무엇인가? DNS(Domain Name System)란 도메인 주소를 IP주소로 변환하는 시스템이다. 즉, 과 같은 컴퓨터의 도메인 이름을 과 같은 IP 주소로 변환해주는 시스템이다. DNS를 왜 사용하는가? 인터넷은 TCP/IP 기초하여 만들어졌다. TCP/IP 기반의 네트워크는 IP주소로 서로 통신하게 된다…","fields":{"slug":"/dns/"},"frontmatter":{"date":"November 03, 2022","title":"DNS(Domain Name System) 이해하기","tags":["DNS","network","domain","NS","IP","TCP"]},"rawMarkdownBody":"\n## DNS(Domain Name System)란 무엇인가?\n\nDNS(Domain Name System)란 도메인 주소를 IP주소로 변환하는 시스템이다. 즉, `www.example.com`과 같은 컴퓨터의 도메인 이름을 `192.168.1.0`과 같은 IP 주소로 변환해주는 시스템이다.\n\n## DNS를 왜 사용하는가?\n\n인터넷은 TCP/IP 기초하여 만들어졌다. TCP/IP 기반의 네트워크는 IP주소로 서로 통신하게 된다. 즉, IP 주소를 모르면 통신이 불가능하다. 그렇다면 통신을 할 때 URL에 IP주소를 사용하면 좋을 것이라고 생각할 수 있다. 실제 IP주소를 사용해도 올바르게 작동한다.\n\n하지만, 전화번호를 기억하기가 어려운 것과 마찬가지로 숫자를 나열한 IP주소는 기억하기 어렵다. 그렇기 때문에 IP주소가 아닌 기억하기 쉬운 도메인명을 사용하는 것이 좋기 때문에 DNS를 사용한다.\n\n## DNS는 어떻게 작동하는가?\n\n### DNS의 기본적인 작동원리\n\nDNS 작동원리를 간단히 설명하면 클라이언트(PC)에서 조회 메시지(이름, 클래스, 타입)를 DNS 서버에 요청하고, DNS 서버는 클라이언트에서 전송한 조회메시지를 확인 후 그에 대응하는 IP주소를 응답하는 방식이다.\n\n![DNS 원리](images/DNS-원리.png)\n\n1. 자신의 PC에 IP 주소뿐만이 아닌 도메인명으로도 접속할 수 있게 하기 위해 DNS 서버에게 자신의 IP주소(`93.184.216.34`)와 도메인명(`example.com`)으로 등록을 요청한다.\n2. DNS 서버는 1번의 요청을 받고 해당 도메인명과 IP주소를 매핑하여 서버에 기록한다.\n3. `example.com`이라는 도메인명을 가진 서버에 접속하고 싶은 클라이언트에서 DNS서버에게 `example.com`도메인명과 함께 IP주소를 응답을 요청한다.\n4. DNS서버는 기록되어있는 도메인명과 맵핑된 IP주소를 응답한다.\n5. IP주소를 응답받은 클라이언트는 해당 IP주소로 서버에 접속한다.\n\n지금까지 기본적인 DNS 작동원리를 살펴보았다. 하지만 DNS의 작동원리는 위처럼 간단하지 않다. 좀 더 상세하게 DNS 작동원리에 대해 알아보자.\n\n### 도메인 계층 구조\n\n우선 도메인 계층 구조를 알아보자. 도메인명은 계층 구조로 되어있으면 맨 오른쪽 생략된 Root(`.`)를 시작으로 뒤에서 앞으로 해석되며 `.` 으로 각 계층의 경계를 표시한다.\n\n![](images/도메인계층구조.png)\n\n위의 그림에서 보이듯이 맨 오른쪽 ‘.’은 Root 도메인이라고 하고, ‘com’은 Top-level 도메인 example 은 Second-level 도메인, blog는 sub 도메인으로 구분 된다.\n\n### DNS 서버 계층 구조\n\nDNS 서버는 도메인 계층과 비슷하게 계층적으로 구성된다. 각 DNS 서버는 자신이 담당하는 영역에 대한 도메인을 관리한다.\n\n![](images/DNS서버-계층구조.png)\n\n위 예시와 같이 루트 DNS 서버 부터 하위로 com, org 등과 같은 최상위 도메인을 관리하는 DNS 서버가 있으며 그 하위로 yahoo, amazon 등과 같은 2차 도메인을 관리하는 DNS서버 그리고 또 그 하위 도메인을 관리하는 DNS서버가 있다.\n\n이렇게 계층적으로 전세계에 수천 수만대의 DNS서버가 협력하여 시스템을 이루고 있다.\n\n<aside>\n💡 루트 DNS 서버는 총 13개이며 최상위 도메인, 2차 도메인 등을 관리하는 DNS 서버는 많은 수의 서버가 존재하고 있다.\n\n</aside>\n\n#### 루트 DNS 서버\n\n루트 DNS 서버는 ICANN 이라는 비영리 단체에서 관리하는 DNS 서버이며, 전 세계에 13대의 루트 DNS 서버가 존재한다.  ~~즉 13대의 루트 DNS 서버를 찾아내어 파괴하면 인터넷을 마비 시킬수 있다~~\n\n![](images/루트네임서버표.png)\n\n#### DNS 서버 탐색 과정\n\nDNS 서버는 각자 담당하는 도메인을 관리하게 되며 상위 DNS 서버는 하위 DNS 서버에 대한 정보를 알고있다. 즉 상위 DNS 서버에 도메인을 요청하면 자신이 알고있는 하위 DNS 서버의 IP주소 목록을 반환하고 해당 IP주소를 통해 다시 하위 DNS를 탐색을 하는 과정을 반복하여 최종적으로 목적지 주소를 알고 있는 DNS로 도달하게 된다.\n\n클라이언트에서 [example.com](http://example.com) 을 접속한다고 가정해보자.\n~~(그림 실력이 엉망이라 죄송합니다ㅠ)~~\n\n![](images/DNS-서버-탐색-과정.png)\n\n> 모든 DNS 서버는 루트 DNS 서버의 주소를 알고 있다.\n1. 클라이언트 PC 브라우저에서 [example.com](http://example.com) 을 입력하면 운영체제에 설정된 DNS 서버에 요청한다.\n2. DNS 서버에 캐시된 example.com의 IP 주소가 존재하면 해당 IP 주소를 반환하고 캐시된 정보가 없으면 ROOT DNS 서버에 요청한다.\n3. ROOT DNS 서버는 example.com의 IP주소를 알지 못함으로 최상위 도메인(com)에 대해 알고 있는 최상위 도메인을 관리하는 DNS 서버의 IP 주소를 응답한다.\n4. DNS 서버는 루트 DNS 서버가 응답한 최상위 DNS 서버의 IP 주소 목록을 확인하여 다시 최상위 DNS 서버에게 요청한다.\n5. 최상위 DNS 서버는 2차 도메인(example)을 알지 못함으로 2차 도메인을 알고 있는 DNS 서버의 IP 주소를 응답한다.\n6. DNS 서버는 최상위 DNS 서버가 응답한 2차 DNS 서버의 IP 주소 목록을 확인하고 2차 DNS 서버에게 요청한다.\n7. 2차 DNS 서버는 example.com에 대한 IP 주소를 알고 있기 때문에 해당 하는 IP 주소를 반환한다.\n8. DNS 서버는 최종목적지의 IP주소를 응답받아 해당 IP를 캐시한 후 클라이언트에게 IP 주소를 응답한다.\n9. 클라이언트 PC는 응답받은 IP주소로 서버에 접속한다.\n\n## 마무리\n\n오늘 글에서는 DNS란 무엇인지, 왜 사용하는지, 어떻게 작동하는지에 대해 알아보았습니다. DNS는 인터넷 세상에서 매우 중요한 역할을 하는 시스템이라고 생각합니다. 오늘 글을 통해서 DNS 시스템에 대해 알고싶은 누군가에게 조금이나마 도움이되었으면 합니다 :)\n\n## 참고\n\n- [WEB2-Domain Name System](https://youtube.com/playlist?list=PLuHgQVnccGMCI75J-rC8yZSVGZq3gYsFp)\n- [성공과 실패를 결정하는 1%의 네트워크 원리](http://www.yes24.com/Product/Goods/90640081)\n- [TCP/IP 쉽게, 더 쉽게](http://www.yes24.com/Product/Goods/32203210)\n- [Dns-server-hierarchy](https://commons.wikimedia.org/wiki/File:Dns-server-hierarchy.gif)\n- [How a DNS Server (Domain Name System) works.](https://www.youtube.com/watch?v=mpQZVYPuDGU&t=188s)"},{"excerpt":"부하테스트 도구 중 하나인 k6로 부하테스트 시작해보자  k6 설치 는 k6에서 사용하는 PGP V4 서명을 지원하지 않기 때문에 설치시 비활성화 옵션을 추가하여 설치 k6 실행 k6는 JavaScript ES6 모듈로 작성할 수 있다. 다음 코드를 복사하여 script.js로 저장하자. 다음 명령으로 k6를 실행할 수 있다. 실행결과    총 290번 …","fields":{"slug":"/k6/"},"frontmatter":{"date":"October 31, 2022","title":"k6로 부하테스트 시작하기","tags":["k6","load-testing","test","grafana","influxDB"]},"rawMarkdownBody":"\n> 부하테스트 도구 중 하나인 k6로 부하테스트 시작해보자 \n\n## k6 설치\n\n`Amazon Linux 2`는 k6에서 사용하는 PGP V4 서명을 지원하지 않기 때문에 설치시 비활성화 옵션을 추가하여 설치\n```shell\n$ sudo yum install https://dl.k6.io/rpm/repo.rpm\n$ sudo yum install --nogpgcheck k6 -y\n```\n\n## k6 실행\nk6는 JavaScript ES6 모듈로 작성할 수 있다.  \n다음 코드를 복사하여 script.js로 저장하자.\n\n```js\nimport http from 'k6/http';\nimport { sleep } from 'k6';\nexport const options = {\n  vus: 10,\n  duration: '30s',\n};\nexport default function () {\n  http.get('http://test.k6.io');\n  sleep(1);\n}\n```\n\n다음 명령으로 k6를 실행할 수 있다.\n```shell\n$ k6 run script.js\n```\n\n## 실행결과\n![k6-실행결과](images/k6-script-result.png)  \n\n총 290번 요청 되었다 `sleep(1)`이 주어졌기 때문이다. 즉, 초당 10명의 가상유저가 30초 동안 요청을 한 것으로 알 수 있다.\n\n이번엔 Grafana와 InfluxDB를 사용하여 모니터링을 해보자.\n\n## Grafana 설치 및 실행\n\n### Grafana YUM 저장소 추가\n```shell\n$ sudo yum update -y\n$ sudo vim /etc/yum.repos.d/grafana.repo\n```\n아래 내용 추가\n```text\n[grafana]\nname=grafana\nbaseurl=https://packages.grafana.com/oss/rpm\nrepo_gpgcheck=1\nenabled=1\ngpgcheck=1\ngpgkey=https://packages.grafana.com/gpg.key\nsslverify=1\nsslcacert=/etc/pki/tls/certs/ca-bundle.crt\n```\n\n### YUM 리포지토리 확인\n```shell\nsudo yum repolist\n```\n![](images/grafana-yum-list.png)\n\n\n### Grafana 설치\n```shell\n$ sudo yum install grafana\n```\n\n### Grafana 실행\n```shell\n$ sudo systemctl start grafana-server\n```\n\n### Grafana 상태 확인\n```shell\n$ sudo systemctl status grafana-server\n```\n![](images/grafana-status.png)\n\n### Grafana 접속\nGrafana는 3000번 포트를 사용합니다.\n초기 비밀번호 : admin / admin\n![](images/grafana-main.png)\n\n\n## InfluxDB 설치 및 실행\n\n### YUM 저장소 추가\n```shell\n$ cat <<EOF | sudo tee /etc/yum.repos.d/influxdb.repo\n```\n아래 내용 추가\n```text\n[influxdb]\nname = InfluxDB Repository - RHEL 7\nbaseurl = https://repos.influxdata.com/rhel/7/x86_64/stable\nenabled = 1\ngpgcheck = 1\ngpgkey = https://repos.influxdata.com/influxdb.key\nEOF\n```\n\n### YUM 리포지토리 확인\n```shell\nsudo yum repolist\n```\n![](images/grafana-yum-list.png)\n\n### InfluxDB 설치\n```shell\n$ sudo yum install influxdb -y\n```\n\n### InfluxDB 실행\n```shell\n$ sudo systemctl start influxdb\n```\n\n### InfluxDB 상태 확인\n```shell\n$ sudo systemctl status influxdb\n```\n![](images/influxdb-status.png)\n\n## InfluxDB를 지정하여 k6 스크립트 실행 \n```shell\n$ k6 run --out influxdb=http://localhost:8086/myk6db script.js\n```\n![](images/k6-script-result.png)\n\n\n## Grafana 설정\n\n### Data Source 추가\n`Configuration` > `Data sources` 메뉴에서 `Add data source` 클릭하여 추가합니다.  \n아래 쪽에 `Database` 항목에 위에서 실행했던 `myk6db`입력 후 `Save & test` 클릭. \n![](images/datasource.png)\n\n### 대시보드 설정\n`Dashboards` > `Import` > 'Import via Grafana.com' 항목에 2587을 입력\n![](images/add-dashboard.png)\n\n'Select a InfluxDB Data source' 항목에 위에서 만들어 둔 InfluxDB 데이터 소스 추가\n![](images/dashboard-influxdb.png)\n\n\n이렇게 k6를 활용하여 부하테스트 진행 및 모니터링을 진행하는 방법을 알아보았다.  \n다음 포스팅에는 k6에서 제공하는 스크립트를 활용한 여러가지 부하테스트를 알아보도록 하자. \n\n## 참고\n* https://k6.io/docs/getting-started/installation\n* https://k6.io/docs/getting-started/running-k6\n* https://k6.io/docs/getting-started/results-output\n* https://www.radishlogic.com/aws/ec2/how-to-install-grafana-on-ec2-amazon-linux-2\n* https://techviewleo.com/how-to-install-influxdb-on-amazon-linux"},{"excerpt":"문제상황 아래 코드는 “Private setters are not allowed for open properties” 컴파일 오류가 발생한다. 원인 JPA를 사용하려면 allopen 플러그인을 사용해야하는데, allopen 플러그인으로 인해 모든 속성 및 메서드가 스프링 구성 요소에서 오픈된다. 그래서 오픈된 속성은 private setter를 만들 수 …","fields":{"slug":"/spring-data-jpa-entity-kotlin-private-setter/"},"frontmatter":{"date":"October 26, 2022","title":"Kotlin에서 JPA Entity 멤버변수 private set 사용 시 주의사항","tags":["kotlin","spring data","JPA","spring"]},"rawMarkdownBody":"\n## 문제상황\n\n아래 코드는 “Private setters are not allowed for open properties” 컴파일 오류가 발생한다.\n\n```kotlin\n@Entity\nclass Product(\n    @Id @Column(columnDefinition = \"BINARY(16)\") val id: UUID,\n    @Embedded val name: DisplayedName,\n    price: Price = Price.ZERO\n) {\n    @Embedded\n    var price: Price = price\n        private set  // private 컴파일오류!\n\n    constructor(name: DisplayedName, price: Long) : this(IdGenerator.createId(), name, Price(price))\n\n    fun changePrice(price: Price) {\n        this.price = price\n    }\n}\n\n```\n\n## 원인\n\nJPA를 사용하려면 allopen 플러그인을 사용해야하는데, allopen 플러그인으로 인해 모든 속성 및 메서드가 스프링 구성 요소에서 오픈된다.  \n그래서 오픈된 속성은 private setter를 만들 수 없다.\n\n## 해결책\n\nJPA를 사용하면 기본생성자도 private으로 선언할 수 없는데 수정자도 마찬가지다\nprivate → protected 로 변경하면 컴파일 오류는 발생하지 않는다.\n\n```kotlin\n@Entity\nclass Product(\n    @Id @Column(columnDefinition = \"BINARY(16)\") val id: UUID,\n    @Embedded val name: DisplayedName,\n    price: Price = Price.ZERO\n) {\n    @Embedded\n    var price: Price = price\n        protected set\n\n    constructor(name: DisplayedName, price: Long) : this(IdGenerator.createId(), name, Price(price))\n\n    fun changePrice(price: Price) {\n        this.price = price\n    }\n}\n```\n\n## 참고\n\n- [https://stackoverflow.com/questions/45153998/what-is-an-open-property-why-i-cant-make-its-setter-to-private](https://stackoverflow.com/questions/45153998/what-is-an-open-property-why-i-cant-make-its-setter-to-private)"},{"excerpt":"01-2. 컴퓨터 구조의 큰 그림 컴퓨터 구조 지식은 크게 두 가지입니다. 하나는 '컴퓨터가 이해하는 정보'이고 또 하나는 ‘컴퓨터의 네 가지 핵심 부품’입니다. 컴퓨터가 이해하는 정보 컴퓨터는 0과 1로 표현된 정보만을 이해합니다. 0과 1로 표현되는 정보에는 크게 두 종류가 있는데, 바로 와 입니다. 데이터(Data) 데이터는 컴퓨터가 이해하는 숫자,…","fields":{"slug":"/1-2-big-picture-computer-system/"},"frontmatter":{"date":"October 26, 2022","title":"혼자 공부하는 컴퓨터구조+운영체제(1-2) - 컴퓨터 구조의 큰 그림","tags":["학습기록","컴퓨터구조","CPU","RAM","데이터","명령어"]},"rawMarkdownBody":"\n# 01-2. 컴퓨터 구조의 큰 그림\n\n> 컴퓨터 구조 지식은 크게 두 가지입니다. 하나는 '**컴퓨터가 이해하는 정보**'이고 또 하나는 ‘**컴퓨터의 네 가지 핵심 부품**’입니다.\n\n## 컴퓨터가 이해하는 정보\n\n컴퓨터는 0과 1로 표현된 정보만을 이해합니다. 0과 1로 표현되는 정보에는 크게 두 종류가 있는데, 바로 `데이터`와 `명령어`입니다.\n\n### **데이터(Data)**\n\n데이터는 컴퓨터가 이해하는 숫자, 문자, 이미지, 동영상과 같은 정적인 정보입니다.\n컴퓨터와 주고받는 정보나 컴퓨터에 저장된 정보를 데이터라 통칭하기도 합니다.\n\n### **명령어(Instruction)**\n\n명령어는 데이터를 움직이고 컴퓨터를 작동시키는 정보입니다. 데이터와 명령어 중 더 중요한 정보는 명령어입니다. 데이터는 명령어 없이는 아무것도 할 수 없는 정보 덩어리일 뿐이기 때문입니다.\n\n즉, 명령어는 컴퓨터를 작동시키는 정보이고, 데이터는 명령어를 위해 존재하는 일종의 재료라고 할 수 있습니다.\n\n> \"**컴퓨터는 도대체 뭘까**?\"라는 질문에 한 마디로 답해보자면 `컴퓨터는 명령어를 처리하는 기계`라고 할 수 있습니다.\n\n## 컴퓨터의 4가지 핵심 부품\n\n컴퓨터를 이루고 있는 네 가지 핵심 부품은 `중앙처리장치(CPU: Central Processing Unit)`, `주기억장치(Main Memory)`, `보조기억장치(Secondary Storage)`, `입출력장치(Input/Output Device)`입니다.\n\n## 중앙처리장치(CPU)\n\nCPU는 컴퓨터의 두뇌입니다. CPU는 메모리에 저장된 명령어를 읽어 들이고, 읽어 들인 명령어를 해석하고, 실행하는 부품입니다. 즉, 컴퓨터에서 명령어를 읽고 연산을 수행하는 것은 CPU입니다.\n\nCPU의 역할과 작동 원리를 구체적으로 이해하기 위해서는 CPU 내부 구성 요소 중 가장 `중요한 산술논리연산장치(ALU: Arithmetic Logic Unit)`, `레지스터(Register)`, `제어장치(CU: Centrol Unit)`에 대해 알아야 합니다.\n\n### 산술논리연산장치(ALU)\n\nALU는 쉽게 말해 계산기로 계산만을 위해 존재하는 부품입니다. 컴퓨터 내부에서 수행되는 대부분의 계산을 수행합니다.\n\n### 레지스터(Register)\n\n레지스터는 CPU 내부의 작은 임시 저장 장치입니다. 프로그램을 실행하는 데 필요한 값들을 임시로 저장하며, CPU 내부에는 여러 개의 레지스터가 존재하고 각기 다른 이름과 역할을 가지고 있습니다.\n\n### 제어장치(CU)\n\n제어장치는 제어 신호(Control Signal)라는 전기 신호를 내보내고 명령어를 해석하는 장치입니다. 시스템 버스 중 제어 버스를 이용하여 메모리를 향해 '메모리 읽기', '메모리 쓰기'와 같은 제어신호를 보내는 장치입니다.\n\n> \"**누가 명령어를 읽고 연산을 수행하는가?**\"라는 질문에는 `CPU`라고 대답할 수 있습니다.\n\n## 메모리\n\n메모리는 현재 실행되는 프로그램의 명령어와 데이터를 저장하는 부품입니다. 즉, 프로그램이 실행되려면 반드시 메모리에 저장되어 있어야 합니다.\n\n메모리는 현실에서 우리가 주소로 원하는 위치를 찾아갈 수 있듯이 컴퓨터에서도 메모리에 저장된 값에 빠르고 효율적으로 접근하기 위해 주소라는 개념을 사용하여 메모리 내 원하는 위치에 접근할 수 있습니다.\n\n> 메모리는 보통 RAM(Random Access Memory)를 지칭합니다.\n\n> \"**어디에서 명령어를 읽는가?**\"라는 질문에는 `RAM`이라고 대답할 수 있습니다.\n\n## 보조기억장치\n\n앞서 메모리는 실행되는 프로그램의 명령어와 데이터를 저장한다고 했지만, 두 가지 치명적인 약점이 있습니다. 첫재는 가격이 비싸 저장 용량이 적다는 점이고, 둘째는 전원이 꺼지면 저장된 내용을 읽는다는 점입니다.\n\n메모리보다 값이 저렴하며 저장용량이 크고 전원이 꺼져도 저장된 내용을 읽지 않으며, 메모리를 보조하는 저장 장치가 보조조기억장치입니다.\n\n하드 디스크, SSD, USB 메모리 DVD, CD-ROM과 같은 저장 장치가 보조기억장치의 일종입니다.\n\n> 메모리가 현재 '실행되는' 프로그램을 저장한다면, 보조기억장치는 '보관할' 프로그램을 저장한다고 생각해도 좋습니다.\n\n\n## 입출력장치\n\n입출력장치는 마이크, 스피커, 프린터, 마우스, 키보드 처럼 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환하는 장치를 의미합니다.\n\n## 참고\n\n- [http://www.yes24.com/Product/Goods/111378840](http://www.yes24.com/Product/Goods/111378840)\n- [https://youtu.be/_uByLEwOt7Q](https://youtu.be/_uByLEwOt7Q)"},{"excerpt":"컴퓨터 구조는 실력 있는 개발자가 되면 반드시 알아야 할 기본 지식입니다. 문제 해결 실무에서, 개발할 때는 문제 없이 작동했던 코드가 실제 사용자들에게 선보이는 자리에서는 작동하지 않는 상황이 비일비재 합니다. 이 경우는 분명 코드상의 문법적인 오류만이 원인이\n아니기 때문에 문제 해결의 실마리를 찾지 못 하면 발만 동동 구르는 상황이 되곤 합니다. 프로…","fields":{"slug":"/1-1-intro-computer-system/"},"frontmatter":{"date":"October 26, 2022","title":"혼자 공부하는 컴퓨터구조+운영체제(1-1) - 컴퓨터 구조를 알아야 하는 이유","tags":["학습기록","컴퓨터구조","문제해결"]},"rawMarkdownBody":"\n> **컴퓨터 구조는 실력 있는 개발자가 되면 반드시 알아야 할 기본 지식입니다.**\n\n## 문제 해결\n\n실무에서, 개발할 때는 문제 없이 작동했던 코드가 실제 사용자들에게 선보이는 자리에서는 작동하지 않는 상황이 비일비재 합니다. 이 경우는 분명 코드상의 문법적인 오류만이 원인이\n아니기 때문에 문제 해결의 실마리를 찾지 못 하면 발만 동동 구르는 상황이 되곤 합니다.\n\n프로그래밍 언어의 문법만 알고 있는 사람에겐 컴퓨터란 코드를 입력하면 어찌어찌 알아서 결과물을 툭 내놓는 ‘미지의 대상’이기 때문입니다.\n\n하지만, **컴퓨터 구조**를 이해하고 있다면 문제 상황을 빠르게 진단할 수 있고, **문제 해결**의 실마리를 다양하게 찾을 수 있습니다.\n컴퓨터 내부를 거리낌 없이 들여다보며 더 좋은 해결책을 고민하기 때문입니다. 이들에게는 컴퓨터란 ‘미지의 대상’이 아닌 **‘분석의 대상’**이기 때문입니다.\n\n> 컴퓨터 구조 지식은 문법에 맞는 코드만 작성할 줄 아는 개발자를 넘어 다양한 문제를 스스로 해결할 줄 아는 개발자로 만들어줍니다.\n\n## 성능, 용량, 비용\n\n직접 만든 웹 사이트를 개발했다고 생각해 봅시다. 웹 사이트를 외부에 공개하기 위해서는 서버 컴퓨터가 필요합니다. 인터넷에서 ‘서버 컴퓨터’를 입력하면 비용도, 저장 용량도\n천차만별인 서버 컴퓨터가 검색됩니다.\n\n이 중에서 어떤 컴퓨터를 고르실 건가요? 무조건 저렴한 게 좋을까요? 아니면 최신 제품이 최고 일까요? 클라우드 서비스를 이용하더라도 마찬가지 입니다. 어떤 CPU를 사용할지,\n어떤 메모리를 사용할지, 직접 판단하고 현명하게 선택해야 합니다.\n\n어떤 선택을 하는지에 따라 **성능, 용량, 비용**이 달라지기 때문입니다.\n\n성능, 용량, 비용 문제는 프로그래밍 언어의 문법만 알아서는 해결하기 어렵습니다.\n그래서 컴퓨터 구조를 아는 것은 매우 중요합니다. 컴퓨터 구조에서 배우는 내용은 결국 성능, 용량, 비용과 직결되기 때문입니다.\n\n즉, 컴퓨터 구조를 이해하면 입력과 출력에만 집중하는 개발을 넘어 성능, 용량, 비용까지 고려하며 개발하는 개발자가 될 수 있습니다.\n\n> **컴퓨터 구조**를 이해하면 문법만으로는 알기 어려운 성능, 용량, 비용을 고려하며 개발할 수 있습니다.\n\n## 정리\n\n- 컴퓨터 구조를 이해하면 **문제 해결** 능력이 향상됩니다.\n- 컴퓨터 구조를 이해하면 문법만으로 알기 어려운 **성능, 용량, 비용**을 고려하며 개발할 수 있습니다.\n\n## 참고\n\n- [http://www.yes24.com/Product/Goods/111378840](http://www.yes24.com/Product/Goods/111378840)"},{"excerpt":"우아한테크세미나 어디 가서 코프링 매우 알은 체하기!를 보고 정리한 내용입니다.    코틀린이란? JVM, 안드로이드, 자바스크립트 및 네이티브를 대상으로 하는  : 모든 프로그램 구성요소의 타입을 컴파일 시점에 알 수 있고 프로그램 안에서 객체의 필드나 메서드를 사용할 때마다 컴파일러가 타입을 검증해 준다는 뜻 젯브레인즈에서 개발한 오픈소스(아파치 라이…","fields":{"slug":"/kotlin-spring-woowahan-tech/"},"frontmatter":{"date":"October 18, 2022","title":"우아한테크세미나 코프링 정리","tags":["kotlin","spring","java","코프링"]},"rawMarkdownBody":"\n> 우아한테크세미나 [어디 가서 코프링 매우 알은 체하기!](https://www.youtube.com/watch?v=ewBri47JWII)를 보고 정리한 내용입니다.   \n\n## 코틀린이란?\n* JVM, 안드로이드, 자바스크립트 및 네이티브를 대상으로 하는 `정적 타입 지정 언어`\n  * `정적 타입 지정 언어`: 모든 프로그램 구성요소의 타입을 컴파일 시점에 알 수 있고 프로그램 안에서 객체의 필드나 메서드를 사용할 때마다 컴파일러가 타입을 검증해 준다는 뜻\n* 젯브레인즈에서 개발한 오픈소스(아파치 라이선스 2.0)\n* OO 스타일과 FP 스타일을 모두 사용할 수 있으며 두 요소를 혼합하여 사용할 수 있다.\n* 간결하고 실용적이며 안전하고 기존 언어와의 상호 운용성을 중시한다.(+코루틴)\n\n## 코틀린의 역사\n* 2011년 7월 코틀린 프로젝트 공개\n* 2012년 6월 안드로이드에서 사용 가능\n* 2016년 2월 코틀린 1.0 출시 / 스프링 이니셜라이저 지원\n* 2017년 1월 스프링 프레임워크 공식 지원\n* 2017년 5월 안드로이드 공식 지원\n* 2018년 11월 그레이들 코틀린 DSL 1.0 출시\n* 2019년 5월 안드로이드 코틀린 퍼스트\n* 2019년 9월 스프링 레퍼런스 예제 코드 제공\n* 2021년 5월 코틀린 1.5 출시\n\n## 얼마나 사용하고 있나요?\n* 지난 12개월 동안 480만 명 이상의 사용자가 사용\n* 대다수의 코틀린 개발자는 안드로이드(64%) 및 서버 측 애플리케이션 개발 (52%)에 사용한다\n* 대한민국에서 가장 인기가 많은 자바, 자연스럽게 코틀린에 대한 관심도 1위(10%)\n\n## 멀티 플랫폼 언어\n* Kotlin은 멀티플랫폼 언어이다.\n* JVM/JS/Native 등\n\n## 아이템 1. 코틀린 표준 라이브러리를 익히고 사용하라\n* 코틀린 1.3부터 모든 플랫폼에서 사용할 수 있는 `kotlin.random.Random`이 도입되었다.\n* 더 이상 `Random`을 사용할지 `ThreadLocalRandom`을 사용할지 고민할 필요가 없다.\n* 자바와 관련된 import문을 제거할 수 있다.\n* 표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 여러분보다 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다.\n* 코틀린은 읽기 전용 컬렉션과 변경 가능한 컬렉션을 구별해 제공한다.\n* 인터페이스를 만족하는 실제 컬렉션이 반환된다. 따라서 플랫폼별 컬렉션을 사용할 수 있다.  \n![코틀린 컬렉션 프레임워크 다이어그램](images/코틀린-공식문서-컬렉션프레임워크-다이어그램.png)\n\n## 코틀린 맛보기\n```kotlin\nclass Person(val name: String, val age: Int = 1) {\n    var nickname: String? = null\n}\n```\n### 자바 변환\n```java\npublic final class Person {\n   @NotNull\n   private final String name;\n   private final int age;\n   \n   @Nullable\n   private String nickname;\n   \n   public Person(String name) {\n      this(name, 1);\n   }\n   \n   public Person(@NotNull String name, int age) {\n      this.name = name;\n      this.age = age;\n   }\n\n   @NotNull\n   public final String getName() {\n      return this.name;\n   }\n   \n   public final int getAge() {\n      return this.age;\n   }\n   \n   @Nullable\n   public final String getNickname() {\n      return this.nickname;\n   }\n\n   public final void setNickname(@Nullable String var1) {\n      this.nickname = var1;\n   }\n}\n```\n\n* 코틀린은 기본적으로 널이 될수 없는 타입이고 의도적으로 `?` 키워드를 선언해야 널이 될 수 있는 타입이 된다.\n* 자바로 변환했을 때 주요 키워드는 `final`이다.\n* 기존 라이브러리를 함께 사용할 때 대부분 `final` 때문에 문제가 발생할 수 있다.\n\n## 아이템 2. 자바로 역컴파일하는 습관을 들여라\n* 코틀린 숙련도를 향상시키는 가장 좋은 방법 중 하나는 작성한 코드가 자바로 어떻게 표현되는지 확인 하는 것이다.\n* 역컴파일을 통해 예기치 않은 코드 생성을 방지할 수 있다.\n* 기존 자바 라이브러리와 프레임워크를 사용하며 문제가 발생할 때 빠르게 확인 할 수 있다.\n* IntelliJ IDEA Tools > Kotlin > Show Kotlin Bytecode => Decompile\n\n### 코틀린 컴파일\n![코틀린 컴파일](images/코틀린-컴파일.png)\n* 코틀린이 먼저 컴파일 된 후 자바가 컴파일 되고, 그 과정에서 애너테이션 프로세싱이 실행된다.\n* `애너테이션` -> 가장 자주 쓰는 것은 `롬복` 애너테이션이다.\n\n## 아이템3. 롬복 대신 데이터 클래스를 사용하라\n* 데이터를 저장하거나 전달하는 것이 주 목적인 클래스를 만드는 경우가 많다. 이러한 클래스의 일부 표준 및 유틸리티 함수는 데이터에서 기계적으로 파생된다.\n* 자바에서는 롬복의 `@Data`를 사용하여 보일러플레이트 코드를 생성한다.\n* 애너테이션 프로세서는 코틀린 컴파일 이후에 동작하기 때문에 롬복에서 생성된 자바 코드는 코틀린 코드에서 접근할 수 없다.\n* 코틀린 코드보다 자바 코드를 먼저 컴파일하도록 빌드 순서를 조정하면 롬복 문제는 해결할 수 있다.\n* 하지만 자바 코드에서 코틀린 코드를 호출할 수 없게 된다.\n* 자바에서 코틀린으로 변환 과정에서 추천하는 방법은 Delombok을 사용하여 작은 단위에 데이터 클래스(DTO등) 부터 점진적으로 변경하는 방법을 추천한다\n\n> [코틀린 1.5.20 부터 롬복 컴파일러 프러그인이 실험적으로 추가되었다.](https://kotlinlang.org/docs/lombok.html)\n\n> [Kotlin 도입 과정에서 만난 문제와 해결방법](https://d2.naver.com/helloworld/6685007)\n\n```kotlin\nval javajigi = Person(name = \"박재성\", age = 49)\nval jason = javajigi.copy(age = 30)\n\ndata class Person(val name: String, val age: Int)\n```\n\n```kotlin\ndata class RecruitmentResponse(\n    val id: Long,\n    val title: String,\n    val term: TermResponse,\n    val recruitable: Boolean,\n    val hidden: Boolean,\n    val startDateTime: LocalDateTime,\n    val endDateTime: LocalDateTime,\n    val status: RecruitmentStatus\n) {\n    constructor(recruitment: Recruitment, term: Term) : this(\n        recruitment.id,\n        recruitment.title,\n        TermResponse(term),\n        recruitment.recruitable,\n        recruitment.hidden,\n        recruitment.startDateTime,\n        recruitment.endDateTime,\n        recruitment.status\n    )\n}\n```\n\n```kotlin\n@Embeddable\ndata class RecruitmentPeriod(\n    @Column(nullable = false)\n    val startDateTime: LocalDateTime,\n\n    @Column(nullable = false)\n    val endDateTime: LocalDateTime\n) {\n    init {\n        require(endDateTime >= startDateTime) { \"시작 일시는 종료 일시보다 이후일 수 없습니다.\" }\n    }\n\n    fun contains(value: LocalDateTime): Boolean = (startDateTime..endDateTime).contains(value)\n}\n```\n\n* 위와 같이 `equals`와 `hashcode` 중요한 객체에서는 데이터클래스를 활용할 수 있다.\n\n\n## Spring Boot\n\n## 아이템 5. 변경 가능성을 제한하라\n\n\n## Persistence\n\n* Entity와 MappedSuperclass 를 왜 allOpen 하는지?\n* 프록시를 만들 수 없어서 레이지 로딩기능이 안되기 때문에 성능에 문제가 발생한다\n\n## 아이템 6. 엔티티에 데이터 클래스 사용을 피하라\n* 롬복의 @Data와 같은 맥락이다. 양방향 연관 관계의 경우 toString(), hashcode()를 호출될 때 무한 순환 참조가 발생한다.\n\n## 아이템 7. 사용자 지정 getter를 사용하라\n\n## 아이템 8. 널이 될 수 있는 타입은 빠르게 제거하라\n\n\n\n## 공부방법\n* 코틀린 공식문서!!\n* 책 - Kotlin in Action 완독 추천\n* 아름다움은 기능을 따라간다 - 설리번(건축가)\n\n## 코틀린\n* 1.5부터는 IR컴파일러 도입하여 더 성능이 좋다\n* 인텔리제이 최신버전 그레이들 최신버전 코틀린 최신버전을 사용하면 3박자가 잘 맞아 재밌게 사용할 수 있다!\n\n## 참고\n* [[LIVE 다시보기] 어디 가서 코프링 매우 알은 체하기! : 9월 우아한테크세미나](https://www.youtube.com/watch?v=ewBri47JWII)"},{"excerpt":"리눅스 서버 설치 후 기본적인 터미널 설정을 진행해봅니다.   인스턴스의  기준으로 작성되었습니다. 터미널 세션 타임아웃(Sessio Timeout) 설정 Sessio Timeout을 설정 하여 일정 시간 작업을 하지 않을 경우 터미널 연결을 해제 하도록 설정할 수 있습니다. 프로파일(.profile) 파일 생성 및 내용 입력  - history 명령 결…","fields":{"slug":"/linux-basic-terminal-settings/"},"frontmatter":{"date":"October 17, 2022","title":"리눅스 서버 터미널 기본 설정","tags":["linux","terminal","shell","aws"]},"rawMarkdownBody":"\n리눅스 서버 설치 후 기본적인 터미널 설정을 진행해봅니다.  \n> `AWS EC2`인스턴스의 `Amazon Linux 2` 기준으로 작성되었습니다.\n\n## 터미널 세션 타임아웃(Sessio Timeout) 설정\nSessio Timeout을 설정 하여 일정 시간 작업을 하지 않을 경우 터미널 연결을 해제 하도록 설정할 수 있습니다.\n\n프로파일(.profile) 파일 생성 및 내용 입력\n```shell\n$ sudo vi ~/.profile\nHISTTIMEFORMAT=\"%F %T -- \"\nexport HISTTIMEFORMAT\nexport TMOUT=600 \n\n$ source ~/.profile\n```\n* `HISTTIMEFORMAT` - history 명령 결과에 시간 값을 추가한다.\n* `TMOUT=600` - 세션 타임아웃을 설정한다(초 단위).\n\n\n## 쉘(Shell) Prompt 변경하기\nBastion 서버 등과 같이 서버를 구분해야하는 경우에 Shell Prompt를 설정하여 서버 관리자의 인적 장애를 예방할 수 있다.\n\n```shell\n$ sudo vi ~/.bashrc\nUSERNAME=BASTION\nPS1='[\\e[1;31m$USERNAME\\e[0m][\\e[1;32m\\t\\e[0m][\\e[1;33m\\u\\e[0m@\\e[1;36m\\h\\e[0m \\w] \\n\\$ \\[\\033[00m\\]'\n\n$ source ~/.bashrc\n```\n\n## Logger를 사용하여 감사로그 남기기\n서버에서 작업할 경우, 작업 이력 히스토리를 기록해 두어야 장애 발싱시 원인 분석을 할 수 있습니다.\n\n```shell\n$ sudo vi ~/.bashrc\ntty=`tty | awk -F\"/dev/\" '{print $2}'`\nIP=`w | grep \"$tty\" | awk '{print $3}'`\nexport PROMPT_COMMAND='logger -p local0.debug \"[USER]$(whoami) [IP]$IP [PID]$$ [PWD]`pwd` [COMMAND] $(history 1 | sed \"s/^[ ]*[0-9]\\+[ ]*//\" )\"'\n\n$ source  ~/.bashrc\n```\n\n```shell\n$ sudo vi /etc/rsyslog.d/50-default.conf\nlocal0.*  /var/log/command.log\n\n$ sudo service rsyslog restart\n$ tail -f /var/log/command.log\n```\n## 참고\n* [인프라 공방](https://edu.nextstep.camp/c/VI4PhjPA/)\n"},{"excerpt":"원격리포지터리를 옮기고 싶은 경우   옵션을 사용하여 깃 커밋 히스토리 그대로 푸시하는 방법을 알아보자.   1. 기존 프로젝트 클론 2. 신규 프로젝트  옵션으로 푸시 3. 기존 프로젝트 삭제 Reference Duplicating a repository","fields":{"slug":"/git-mirror/"},"frontmatter":{"date":"July 29, 2022","title":"Git 저장소 복제 하기","tags":["git","github","repository"]},"rawMarkdownBody":" \n\n원격리포지터리를 옮기고 싶은 경우  `--mirror` 옵션을 사용하여 깃 커밋 히스토리 그대로 푸시하는 방법을 알아보자.  \n\n\n### 1. 기존 프로젝트 클론\n```bash\n$ git clone --bare https://github.com/exampleuser/old-repository.git\n```\n\n### 2. 신규 프로젝트 `--mirror` 옵션으로 푸시\n```bash\n$ cd old-repository.git\n$ git push --mirror https://github.com/exampleuser/new-repository.git\n```\n\n### 3. 기존 프로젝트 삭제\n```bash\n$ cd ..\n$ rm -rf old-repository.git\n```\n\n## Reference\n---\n* [Duplicating a repository](https://docs.github.com/en/repositories/creating-and-managing-repositories/duplicating-a-repository)\n"},{"excerpt":"EC2 구성 AMI - Amazon Linux 2 AMI (HVM) - Kernel 5.10, SSD Volume Type 선택 도커 및 Git 설치 도커 컴포즈 설치 Pinpoint 설치 위 명령어 실행시 아래 와 같이 오류 발생하여 권한처리 후 정상동작 확인 Pinpoint Web 접속 http://[Pinpoint-Web-host]:8079 Samp…","fields":{"slug":"/pinpoint-install-with-docker/"},"frontmatter":{"date":"June 15, 2022","title":"AWS EC2 Pinpoint 설치 with docker","tags":["pinpoint","aws","java","apm","docker","docker-compose"]},"rawMarkdownBody":" \n\n## EC2 구성\n* AMI - **Amazon Linux 2 AMI (HVM) - Kernel 5.10, SSD Volume Type 선택**\n\n## 도커 및 Git 설치\n\n```bash\n# docker 설치\nsudo amazon-linux-extras install docker\n\n# docker 실행\nsudo service docker start\n\n# docker 사용자 ec2-user 그룹에 추가\nsudo usermod -a -G docker ec2-user\n\n# Git 설치\nsudo yum install git -y\n\n# 재부팅\nsudo reboot\n```\n\n## 도커 컴포즈 설치\n\n```bash\n# docker-compose 설치\nsudo curl -L https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose\n\n# 권한 수정\nsudo chmod +x /usr/local/bin/docker-compose\n\n# Verify\ndocker-compose version\n```\n\n## Pinpoint 설치\n\n```bash\ngit clone https://github.com/naver/pinpoint-docker.git\ncd pinpoint-docker\ndocker-compose pull && docker-compose up -d\n```\n\n## 위 명령어 실행시 아래 와 같이 오류 발생하여 권한처리 후 정상동작 확인\n\n```bash\n# docker-compose pull && docker-compose up -d 실행 시 오류 발생!!\nGot permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get \"http://%2Fvar%2Frun%2Fdocker.sock/v1.24/info\": dial unix /var/run/docker.sock: connect: permission denied\n\n# docker.sock 권한 변경\nsudo chmod 666 /var/run/docker.sock\n\n# 다시 실행\ndocker-compose pull && docker-compose up -d\n```\n\n## Pinpoint Web 접속\n\n- http://[Pinpoint-Web-host]:8079\n- Sample App(quickapp) 앱 확인\n\n![pinpoint-demo](images/demo.png)\n\n## Reference\n* [https://gist.github.com/npearce/6f3c7826c7499587f00957fee62f8ee9](https://gist.github.com/npearce/6f3c7826c7499587f00957fee62f8ee9)\n* [https://pinpoint-apm.gitbook.io/pinpoint/](https://pinpoint-apm.gitbook.io/pinpoint/)\n* [https://newbedev.com/shell-error-got-permission-denied-while-trying-to-connect-to-the-docker-daemon-socket-at-unix-var-run-docker-sock-get-http-2fvar-2frun-2fdocker-sock-v1-24-info-dial-unix-var-run-docker-sock-connect-permission-denied-code-example](https://newbedev.com/shell-error-got-permission-denied-while-trying-to-connect-to-the-docker-daemon-socket-at-unix-var-run-docker-sock-get-http-2fvar-2frun-2fdocker-sock-v1-24-info-dial-unix-var-run-docker-sock-connect-permission-denied-code-example)"},{"excerpt":"EC2 구성 Hbase, Collector, Web 하나의 EC2에 설치 AMI - Amazon Linux 2 AMI (HVM) - Kernel 5.10, SSD Volume Type 선택 Security Group InBound Open Port: 8000 - 9999 Pinpoint 설치 java 8 설치(Hbase 버전 지원으로 인해 java 8설치…","fields":{"slug":"/pinpoint-install/"},"frontmatter":{"date":"June 15, 2022","title":"AWS EC2 Pinpoint 설치","tags":["pinpoint","aws","java","apm"]},"rawMarkdownBody":"\n## EC2 구성\n* Hbase, Collector, Web 하나의 EC2에 설치\n* AMI - **Amazon Linux 2 AMI (HVM) - Kernel 5.10, SSD Volume Type 선택**\n* Security Group InBound Open Port: 8000 - 9999\n\n## Pinpoint 설치\njava 8 설치(Hbase 버전 지원으로 인해 java 8설치\n\n![Screen Shot 2022-01-10 at 3.16.01 PM.png](images/java-support-by-release-line.png)\n\n```bash\n# Java 8 설치\nsudo yum install -y java-1.8.0-openjdk-devel.x86_64\n\nreadlink -f /usr/bin/java\n# /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.312.b07-1.amzn2.0.2.x86_64/jre/bin/java\n# java 경로까지만 처리\n\nsudo vim /etc/profile\n# export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.312.b07-1.amzn2.0.2.x86_64\n# 해당 파일 제일 하단에 입력 후 재접속\n\n# 확인\necho $JAVA_HOME\n# /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.312.b07-1.amzn2.0.2.x86_64\n\n```\n\nHbase 설치\n\n```bash\n# HBase 다운로드\nwget https://archive.apache.org/dist/hbase/1.4.14/hbase-1.4.14-bin.tar.gz\n\n# 압축해제\ntar xvf hbase-1.4.14-bin.tar.gz\n\n# create symbolic link\nln -s hbase-1.4.14 hbase\n\n# Start hbase\nhbase/bin/start-hbase.sh\n\n# Pinpoint 에서 제공하는 Hbase 스크립트 다운로드\nwget https://raw.githubusercontent.com/pinpoint-apm/pinpoint/master/hbase/scripts/hbase-create.hbase\n\n# 스크립트 실행\nhbase/bin/hbase shell hbase-create.hbase\n```\n\n## Pinpoint Collector 설치\n\n```bash\n# Download Collector \nwget https://github.com/pinpoint-apm/pinpoint/releases/download/v2.3.3/pinpoint-collector-boot-2.3.3.jar\n\n# 실행권한 부여\nchmod +x pinpoint-collector-boot-2.3.3.jar\n\n# 실행\nnohup java -jar -Dpinpoint.zookeeper.address=localhost pinpoint-collector-boot-2.3.3.jar >/dev/null 2>&1 &\n```\n\n## Pinpoint Web 설치\n\n```bash\n# Download Web\nwget https://github.com/pinpoint-apm/pinpoint/releases/download/v2.3.3/pinpoint-web-boot-2.3.3.jar\n\n# 실행권한 부여\nchmod +x pinpoint-web-boot-2.3.3.jar\n\n# 실행\nnohup java -jar -Dpinpoint.zookeeper.address=localhost pinpoint-web-boot-2.3.3.jar >/dev/null 2>&1 &\n```\n\n## Reference\n* [https://jojoldu.tistory.com/573](https://jojoldu.tistory.com/573)\n* [https://hbase.apache.org/book.html](https://hbase.apache.org/book.html)\n* [https://pinpoint-apm.gitbook.io/pinpoint/](https://pinpoint-apm.gitbook.io/pinpoint/)"}]}},"pageContext":{}},"staticQueryHashes":[]}