{"componentChunkName":"component---src-templates-post-jsx","path":"/clean-code/","result":{"data":{"site":{"siteMetadata":{"title":"devdog.blog"}},"markdownRemark":{"id":"e8166b9c-3311-5f68-8a6a-c68d2bc64179","excerpt":"작게 만들어라! 함수를 만드는 첫째 규칙은'작게!'다. 함수를 만드는 둘째 규칙은 '더 작게!'다 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다. 당연한 말이지만, 그래야 함수는 읽고 이해하기 쉬워진다. 한 가지만 해라! 함수는 한 가지를 해야한다. 그 한가지를 잘 해야한다. 그 한 가지만을 해야 한다. 의미 있는 이름으로 다른 함수를 추출할…","html":"<h2>작게 만들어라!</h2>\n<ul>\n<li>함수를 만드는 첫째 규칙은'작게!'다. 함수를 만드는 둘째 규칙은 '더 작게!'다</li>\n<li>함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다. 당연한 말이지만, 그래야 함수는 읽고 이해하기 쉬워진다.</li>\n</ul>\n<h2>한 가지만 해라!</h2>\n<ul>\n<li>함수는 한 가지를 해야한다. 그 한가지를 잘 해야한다. 그 한 가지만을 해야 한다.</li>\n<li>의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다.</li>\n</ul>\n<h2>함수당 추상화 수준은 하나로!</h2>\n<ul>\n<li>함수가 확실히 '한 가지' 작업만 하려면 함수 내 모든 문자의 추상화 수준이 동일해야 한다.</li>\n<li>위 에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다. 나는 이것을 <code class=\"language-text\">내려가기 규칙</code>이라 부른다.</li>\n</ul>\n<h2>서술적인 이름을 사용하라!</h2>\n<ul>\n<li>좋은 이름이 주는 가치는 아무리 강조해도 지나치치 않다.</li>\n<li>한 가지만 하는 작은 함수에 좋은 이름을 붙인다면 이런 원칙을 달성함에 있어 이미 절반은 성공했다.</li>\n</ul>\n<h2>함수 인수</h2>\n<ul>\n<li>함수에서 이상적인 인수 개수는 0개(무항)다. 다음은 1개(단항)고, 다음은 2개(이항)다 3개(삼항)는 가능한 피하는 편이 좋다. 4개 이상(다항)은 특별한 이유가 필요하다.\n특별한 이유가 있어도 사용하면 안된다.</li>\n<li>변환 함수에서 출력 인수를 사용하면 혼란을 일으킨다.</li>\n<li>플래그 인수는 추하다. 함수가 한꺼번에 여러가지를 처리한다고 대놓고 공표하는 셈이니까!</li>\n<li>인수가 2-3개 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 짚어본다.</li>\n<li>단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야 한다.</li>\n</ul>\n<h2>부수 효과를 일으키지 마라!</h2>\n<ul>\n<li>부수 효과는 거짓말이다. 함수에서 한 가지를 하겠다고 약속하고선 남모래 다른 짓도 하니까.</li>\n<li>일반적으로 출력 인수는 피해야 한다. 함수에서 상태를 변경해야 한다면 함수가 속한 객체 상태를 변경하는 방식을 택한다.</li>\n</ul>\n<h2>명령과 조회를 분리하라!</h2>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// \"set\"이라는 단어가 동사인지 형용사인지 분간하기 어렵다.</span>\n<span class=\"token comment\">// 함수를 구현한 개발자는 \"set\"을 동사로 의도했다. 하지만 if 문에 넣고 보면 형용사로 느껴진다.  </span>\n<span class=\"token comment\">// 그래서 if 문은 \"username 속성이 unclebob으로 설정되 어 있다면...”으로 읽힌다.  </span>\n<span class=\"token comment\">// \"username을 unclebob으로 설정하는데 성공하면\"으로 읽히지 않는다.</span>\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"username\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"unclebob\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">attributeExists</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"username\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"username\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"unclebob\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 명령과 조회를 분리하라!</span>\n    <span class=\"token punctuation\">}</span></code></pre></div>\n<h2>오류 코드보다 예외를 사용하라!</h2>\n<ul>\n<li>명령 함수에서 오류 코드를 반환하는 방식은 명령/조회 분리 규칙을 미묘하게 위반한다.</li>\n<li>오류 코드 대신 예외를 사용하면 오류 처리 코드가 원래 코드에서 분리되므로 코드가 깔끔해진다.</li>\n</ul>\n<h2>try/catch 블록은 원래추하다.</h2>\n<ul>\n<li>코드 구조에 혼란을 일으키며, 정상 동작과 오류 처리 동작을 뒤섞는다. 그러므로 try/catch 블록을 별도 함수로 뽑아내는 편이 좋다.</li>\n</ul>\n<h2>오류 처리도 한 가지 작업이다.</h2>\n<ul>\n<li>함수는 '한 가지' 작업만 해야 한다. 오류 처리도 '한 가지' 작업에 속한다. 그러므로 오류를 처리하는 함수는 오류만 처리해야 마땅하다.</li>\n</ul>\n<h2>반복하지 마라!</h2>\n<ul>\n<li>중복은 소프트웨어에서 모든 악의 근원이다.</li>\n</ul>\n<h2>함수를 어떻게 짜죠?</h2>\n<ul>\n<li>소프트웨어를 짜는 행위는 여느 글짓기와 비슷하다.</li>\n<li>처음부터 탁 짜내지 않는다. 그게 가능한 사람은 없으리라.</li>\n</ul>\n<h2>결론</h2>\n<ul>\n<li>프로그래밍의 기술은 언제나 언어 설계의 기술이다.</li>\n<li>대가 프로그래머는 시스템을 (구현할) 프로그램이 아니라 (풀어갈) 이야기로 여긴다. 프로그래밍 언어라는 수단을 사용해 좀 더 풍부하고 좀 더 표현력이 강한 언어를 만들어\n이야기를 풀어간다.</li>\n<li>함수 계층이 바로 그 언어에 속한다.</li>\n</ul>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"http://www.yes24.com/Product/Goods/11681152\">Clean Code</a></li>\n</ul>","frontmatter":{"title":"[Clean Code] 3장 함수","date":"June 13, 2022","update":"June 13, 2022","tags":["clean-code","Clean Code","function","container"],"series":"Book - Clean Code"},"fields":{"slug":"/clean-code/","readingTime":{"minutes":5.805}}},"seriesList":{"edges":[{"node":{"id":"e8166b9c-3311-5f68-8a6a-c68d2bc64179","fields":{"slug":"/clean-code/"},"frontmatter":{"title":"[Clean Code] 3장 함수"}}}]},"previous":{"fields":{"slug":"/docker/"},"frontmatter":{"title":"Docker 시작하기"}},"next":null},"pageContext":{"id":"e8166b9c-3311-5f68-8a6a-c68d2bc64179","series":"Book - Clean Code","previousPostId":"97fec35b-4416-5759-811d-2e0d1f8b44be","nextPostId":null}},"staticQueryHashes":[]}